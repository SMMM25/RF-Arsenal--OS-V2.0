#!/usr/bin/env python3
"""
RF Arsenal OS - API Security Testing Module
============================================

Professional API security testing with stealth-first design.
Comprehensive testing for REST, GraphQL, JWT, OAuth, and access control vulnerabilities.

CAPABILITIES:
- REST API fuzzing and vulnerability detection
- GraphQL introspection, batching, and query complexity attacks
- JWT token analysis, signature bypass, and key confusion attacks
- OAuth/OIDC flow manipulation and token theft
- BOLA/BFLA (Broken Object/Function Level Authorization) testing
- Rate limit bypass and API abuse detection
- Mass assignment and parameter pollution

README COMPLIANCE:
- Stealth-First: Randomized timing, proxy support, fingerprint obfuscation
- RAM-Only: All data stored in memory, secure wipe on exit
- No Telemetry: Zero external data transmission
- Offline-First: Core functionality works without network (analysis modes)

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import base64
import hashlib
import hmac
import json
import logging
import os
import random
import re
import secrets
import ssl
import struct
import time
import urllib.parse
from abc import ABC, abstractmethod
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

# Optional dependencies with graceful fallback
try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
    from cryptography.hazmat.backends import default_backend
    from cryptography.x509 import load_pem_x509_certificate
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS AND DATA CLASSES
# =============================================================================

class APIVulnType(Enum):
    """API vulnerability types following OWASP API Security Top 10"""
    # OWASP API Top 10 2023
    BOLA = "broken_object_level_authorization"  # API1
    BROKEN_AUTH = "broken_authentication"  # API2
    BOPLA = "broken_object_property_level_authorization"  # API3
    UNRESTRICTED_RESOURCE = "unrestricted_resource_consumption"  # API4
    BFLA = "broken_function_level_authorization"  # API5
    UNRESTRICTED_ACCESS = "unrestricted_access_to_sensitive_flows"  # API6
    SSRF = "server_side_request_forgery"  # API7
    SECURITY_MISCONFIG = "security_misconfiguration"  # API8
    IMPROPER_INVENTORY = "improper_inventory_management"  # API9
    UNSAFE_API_CONSUMPTION = "unsafe_api_consumption"  # API10
    # Additional API vulnerabilities
    JWT_NONE_ALG = "jwt_none_algorithm"
    JWT_WEAK_SECRET = "jwt_weak_secret"
    JWT_KEY_CONFUSION = "jwt_key_confusion"
    JWT_EXPIRED_ACCEPTED = "jwt_expired_accepted"
    OAUTH_REDIRECT = "oauth_open_redirect"
    OAUTH_TOKEN_LEAK = "oauth_token_leakage"
    OAUTH_CSRF = "oauth_csrf"
    GRAPHQL_INTROSPECTION = "graphql_introspection_enabled"
    GRAPHQL_BATCHING = "graphql_batching_attack"
    GRAPHQL_DEPTH = "graphql_depth_attack"
    GRAPHQL_INJECTION = "graphql_injection"
    MASS_ASSIGNMENT = "mass_assignment"
    PARAMETER_POLLUTION = "http_parameter_pollution"
    RATE_LIMIT_BYPASS = "rate_limit_bypass"
    VERB_TAMPERING = "http_verb_tampering"
    IDOR = "insecure_direct_object_reference"
    INFO_DISCLOSURE = "information_disclosure"
    CORS_MISCONFIG = "cors_misconfiguration"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


class AuthType(Enum):
    """API authentication types"""
    NONE = "none"
    BASIC = "basic"
    BEARER = "bearer"
    API_KEY = "api_key"
    OAUTH2 = "oauth2"
    JWT = "jwt"
    HMAC = "hmac"
    CUSTOM = "custom"


class HTTPMethod(Enum):
    """HTTP methods"""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    PATCH = "PATCH"
    DELETE = "DELETE"
    OPTIONS = "OPTIONS"
    HEAD = "HEAD"
    TRACE = "TRACE"


@dataclass
class APIVulnerability:
    """Detected API vulnerability"""
    vuln_type: APIVulnType
    severity: SeverityLevel
    endpoint: str
    method: HTTPMethod
    description: str
    evidence: Optional[str] = None
    payload: Optional[str] = None
    parameter: Optional[str] = None
    remediation: str = ""
    confidence: float = 0.0
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    timestamp: datetime = field(default_factory=datetime.now)
    request_data: Optional[Dict] = None
    response_data: Optional[Dict] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for reporting"""
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'endpoint': self.endpoint,
            'method': self.method.value,
            'description': self.description,
            'evidence': self.evidence[:1000] if self.evidence else None,
            'payload': self.payload,
            'parameter': self.parameter,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class JWTToken:
    """Parsed JWT token"""
    raw: str
    header: Dict[str, Any]
    payload: Dict[str, Any]
    signature: bytes
    algorithm: str
    is_valid: bool = False
    expiry: Optional[datetime] = None
    issuer: Optional[str] = None
    subject: Optional[str] = None
    audience: Optional[str] = None
    
    @classmethod
    def decode(cls, token: str) -> 'JWTToken':
        """Decode JWT token without validation"""
        parts = token.split('.')
        if len(parts) != 3:
            raise ValueError("Invalid JWT format")
        
        # Decode header
        header_b64 = parts[0] + '=' * (4 - len(parts[0]) % 4)
        header = json.loads(base64.urlsafe_b64decode(header_b64))
        
        # Decode payload
        payload_b64 = parts[1] + '=' * (4 - len(parts[1]) % 4)
        payload = json.loads(base64.urlsafe_b64decode(payload_b64))
        
        # Signature
        sig_b64 = parts[2] + '=' * (4 - len(parts[2]) % 4)
        try:
            signature = base64.urlsafe_b64decode(sig_b64)
        except Exception:
            signature = b''
        
        # Extract claims
        expiry = None
        if 'exp' in payload:
            try:
                expiry = datetime.fromtimestamp(payload['exp'])
            except Exception:
                pass
        
        return cls(
            raw=token,
            header=header,
            payload=payload,
            signature=signature,
            algorithm=header.get('alg', 'unknown'),
            expiry=expiry,
            issuer=payload.get('iss'),
            subject=payload.get('sub'),
            audience=payload.get('aud'),
        )
    
    def encode_none_alg(self) -> str:
        """Re-encode token with 'none' algorithm (attack)"""
        new_header = {**self.header, 'alg': 'none'}
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(new_header).encode()
        ).rstrip(b'=').decode()
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(self.payload).encode()
        ).rstrip(b'=').decode()
        return f"{header_b64}.{payload_b64}."
    
    def encode_with_secret(self, secret: str, algorithm: str = 'HS256') -> str:
        """Re-encode token with a secret"""
        new_header = {**self.header, 'alg': algorithm}
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(new_header).encode()
        ).rstrip(b'=').decode()
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(self.payload).encode()
        ).rstrip(b'=').decode()
        
        message = f"{header_b64}.{payload_b64}".encode()
        
        if algorithm == 'HS256':
            signature = hmac.new(secret.encode(), message, hashlib.sha256).digest()
        elif algorithm == 'HS384':
            signature = hmac.new(secret.encode(), message, hashlib.sha384).digest()
        elif algorithm == 'HS512':
            signature = hmac.new(secret.encode(), message, hashlib.sha512).digest()
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
        
        sig_b64 = base64.urlsafe_b64encode(signature).rstrip(b'=').decode()
        return f"{header_b64}.{payload_b64}.{sig_b64}"
    
    def modify_payload(self, updates: Dict[str, Any]) -> 'JWTToken':
        """Create new token with modified payload"""
        new_payload = {**self.payload, **updates}
        return JWTToken(
            raw=self.raw,
            header=self.header,
            payload=new_payload,
            signature=self.signature,
            algorithm=self.algorithm,
        )


@dataclass
class APIEndpoint:
    """Discovered API endpoint"""
    url: str
    method: HTTPMethod
    parameters: List[Dict[str, Any]] = field(default_factory=list)
    auth_required: bool = False
    auth_type: AuthType = AuthType.NONE
    response_schema: Optional[Dict] = None
    description: str = ""
    tags: List[str] = field(default_factory=list)


@dataclass
class APISecurityConfig:
    """API security testing configuration"""
    # Target
    base_url: str
    endpoints: List[str] = field(default_factory=list)
    
    # Authentication
    auth_type: AuthType = AuthType.NONE
    auth_token: Optional[str] = None
    auth_header: str = "Authorization"
    api_key_name: Optional[str] = None
    api_key_location: str = "header"  # header, query, cookie
    
    # Test credentials (for privilege escalation testing)
    low_priv_token: Optional[str] = None
    high_priv_token: Optional[str] = None
    other_user_ids: List[str] = field(default_factory=list)
    
    # Stealth settings
    delay_min: float = 0.5
    delay_max: float = 2.0
    randomize_timing: bool = True
    rotate_user_agents: bool = True
    use_proxy: bool = False
    proxy_url: Optional[str] = None
    
    # Test modules
    test_jwt: bool = True
    test_oauth: bool = True
    test_bola: bool = True
    test_bfla: bool = True
    test_graphql: bool = True
    test_rate_limits: bool = True
    test_mass_assignment: bool = True
    test_verb_tampering: bool = True
    
    # Limits
    timeout: float = 30.0
    max_requests: int = 1000
    max_concurrent: int = 10


# =============================================================================
# API SECURITY SCANNER
# =============================================================================

class APISecurityScanner:
    """
    Professional API Security Scanner
    
    Comprehensive API security testing with:
    - REST API vulnerability scanning
    - GraphQL security testing
    - JWT token analysis and attacks
    - OAuth/OIDC flow testing
    - BOLA/BFLA detection
    - Rate limit bypass testing
    
    README COMPLIANCE:
    - Stealth-First: Request randomization and proxy support
    - RAM-Only: All results in memory
    - No Telemetry: Zero external reporting
    - Authorization Required: Explicit consent for attacks
    """
    
    # User agents for rotation
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/121.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/121.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/121.0.0.0 Safari/537.36",
        "PostmanRuntime/7.36.0",
        "insomnia/8.6.0",
    ]
    
    # Common weak JWT secrets
    WEAK_JWT_SECRETS = [
        "secret", "password", "123456", "key", "private",
        "jwt_secret", "token_secret", "auth_secret",
        "your-256-bit-secret", "your-512-bit-secret",
        "supersecret", "changeme", "default", "test",
        "development", "production", "staging",
    ]
    
    # BOLA test patterns (ID manipulation)
    BOLA_PATTERNS = [
        ("1", "2"),
        ("100", "101"),
        ("user1", "user2"),
        ("{id}", "{id}+1"),
        ("{uuid}", "00000000-0000-0000-0000-000000000000"),
    ]
    
    # Mass assignment dangerous fields
    MASS_ASSIGNMENT_FIELDS = [
        "role", "admin", "is_admin", "isAdmin", "administrator",
        "privilege", "privileges", "permission", "permissions",
        "access_level", "accessLevel", "user_type", "userType",
        "verified", "is_verified", "active", "is_active",
        "balance", "credits", "points", "subscription",
        "plan", "tier", "level", "group", "groups",
    ]
    
    def __init__(self, config: Optional[APISecurityConfig] = None):
        """Initialize API security scanner"""
        self.config = config
        self.vulnerabilities: List[APIVulnerability] = []
        self.endpoints: List[APIEndpoint] = []
        self.stats = defaultdict(int)
        self._running = False
        self._lock = asyncio.Lock()
        self._authorized = False
        self._authorization_time: Optional[datetime] = None
        
        logger.info("APISecurityScanner initialized - RAM-only, stealth mode")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_API_TESTING") -> bool:
        """
        Authorize API security testing
        
        Args:
            confirmation: Confirmation string
            
        Returns:
            True if authorized
        """
        if confirmation == "I_AUTHORIZE_API_TESTING":
            self._authorized = True
            self._authorization_time = datetime.now()
            logger.info("API security testing authorized")
            return True
        return False
    
    def _check_authorization(self) -> bool:
        """Check if testing is authorized"""
        if not self._authorized:
            return False
        # Authorization expires after 60 minutes
        if self._authorization_time:
            elapsed = datetime.now() - self._authorization_time
            if elapsed > timedelta(minutes=60):
                self._authorized = False
                return False
        return True
    
    def _get_random_user_agent(self) -> str:
        """Get random user agent for stealth"""
        return random.choice(self.USER_AGENTS)
    
    def _get_headers(self, auth_token: Optional[str] = None) -> Dict[str, str]:
        """Get request headers with stealth and auth"""
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
            "Cache-Control": "no-cache",
        }
        
        if self.config and self.config.rotate_user_agents:
            headers["User-Agent"] = self._get_random_user_agent()
        else:
            headers["User-Agent"] = self.USER_AGENTS[0]
        
        # Add authentication
        token = auth_token or (self.config.auth_token if self.config else None)
        if token and self.config:
            if self.config.auth_type == AuthType.BEARER:
                headers[self.config.auth_header] = f"Bearer {token}"
            elif self.config.auth_type == AuthType.JWT:
                headers[self.config.auth_header] = f"Bearer {token}"
            elif self.config.auth_type == AuthType.API_KEY:
                if self.config.api_key_location == "header":
                    headers[self.config.api_key_name or "X-API-Key"] = token
            elif self.config.auth_type == AuthType.BASIC:
                headers[self.config.auth_header] = f"Basic {token}"
        
        return headers
    
    async def _delay(self):
        """Apply stealth delay"""
        if self.config and self.config.randomize_timing:
            delay = random.uniform(self.config.delay_min, self.config.delay_max)
            await asyncio.sleep(delay)
    
    async def _make_request(
        self,
        url: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        json_data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        auth_token: Optional[str] = None,
        allow_redirects: bool = True,
    ) -> Tuple[Optional[int], Optional[str], Optional[Dict], float]:
        """
        Make HTTP request with stealth features
        
        Returns: (status_code, response_text, response_headers, response_time)
        """
        if not AIOHTTP_AVAILABLE:
            logger.error("aiohttp not available")
            return None, None, None, 0.0
        
        await self._delay()
        
        request_headers = self._get_headers(auth_token)
        if headers:
            request_headers.update(headers)
        
        start_time = time.time()
        
        try:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
            connector = aiohttp.TCPConnector(ssl=ssl_context)
            timeout = aiohttp.ClientTimeout(
                total=self.config.timeout if self.config else 30.0
            )
            
            proxy = None
            if self.config and self.config.use_proxy and self.config.proxy_url:
                proxy = self.config.proxy_url
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
            ) as session:
                request_kwargs = {
                    "headers": request_headers,
                    "allow_redirects": allow_redirects,
                    "proxy": proxy,
                }
                
                if json_data:
                    request_kwargs["json"] = json_data
                elif data:
                    request_kwargs["data"] = data
                
                async with session.request(method.upper(), url, **request_kwargs) as response:
                    text = await response.text()
                    response_time = time.time() - start_time
                    self.stats['requests'] += 1
                    return response.status, text, dict(response.headers), response_time
        
        except asyncio.TimeoutError:
            self.stats['timeouts'] += 1
            return None, None, None, time.time() - start_time
        except aiohttp.ClientError as e:
            self.stats['errors'] += 1
            logger.debug(f"Request error: {e}")
            return None, None, None, time.time() - start_time
        except Exception as e:
            self.stats['errors'] += 1
            logger.debug(f"Unexpected error: {e}")
            return None, None, None, time.time() - start_time
    
    async def _add_vulnerability(self, vuln: APIVulnerability):
        """Add vulnerability to results (thread-safe)"""
        async with self._lock:
            # Check for duplicates
            for existing in self.vulnerabilities:
                if (existing.vuln_type == vuln.vuln_type and
                    existing.endpoint == vuln.endpoint and
                    existing.method == vuln.method and
                    existing.parameter == vuln.parameter):
                    return
            
            self.vulnerabilities.append(vuln)
            self.stats['vulnerabilities'] += 1
            logger.info(f"[{vuln.severity.value.upper()}] {vuln.vuln_type.value}: {vuln.endpoint}")
    
    # =========================================================================
    # JWT SECURITY TESTING
    # =========================================================================
    
    async def test_jwt_security(self, token: str, endpoint: str) -> List[APIVulnerability]:
        """
        Comprehensive JWT security testing
        
        Tests:
        - None algorithm attack
        - Weak secret brute force
        - Algorithm confusion (RS256 -> HS256)
        - Expired token acceptance
        - Signature stripping
        - Claim manipulation
        """
        vulnerabilities = []
        
        try:
            jwt = JWTToken.decode(token)
        except Exception as e:
            logger.debug(f"Failed to decode JWT: {e}")
            return vulnerabilities
        
        logger.info(f"Testing JWT security for {endpoint}")
        logger.info(f"JWT Algorithm: {jwt.algorithm}, Claims: {list(jwt.payload.keys())}")
        
        # Test 1: None algorithm attack
        none_token = jwt.encode_none_alg()
        status, response, _, _ = await self._make_request(
            endpoint,
            headers={"Authorization": f"Bearer {none_token}"}
        )
        
        if status and status < 400:
            vuln = APIVulnerability(
                vuln_type=APIVulnType.JWT_NONE_ALG,
                severity=SeverityLevel.CRITICAL,
                endpoint=endpoint,
                method=HTTPMethod.GET,
                description="JWT 'none' algorithm accepted - authentication bypass possible",
                evidence=f"Server accepted token with alg=none, response: {status}",
                payload=none_token[:100] + "...",
                remediation="Explicitly validate JWT algorithm, reject 'none' algorithm",
                confidence=0.95,
                cwe_id="CWE-347",
                cvss_score=9.8,
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        
        # Test 2: Weak secret attack (for HMAC algorithms)
        if jwt.algorithm.startswith('HS'):
            for secret in self.WEAK_JWT_SECRETS:
                try:
                    test_token = jwt.encode_with_secret(secret, jwt.algorithm)
                    status, response, _, _ = await self._make_request(
                        endpoint,
                        headers={"Authorization": f"Bearer {test_token}"}
                    )
                    
                    if status and status < 400:
                        vuln = APIVulnerability(
                            vuln_type=APIVulnType.JWT_WEAK_SECRET,
                            severity=SeverityLevel.CRITICAL,
                            endpoint=endpoint,
                            method=HTTPMethod.GET,
                            description=f"JWT signed with weak secret: '{secret}'",
                            evidence=f"Forged token accepted with secret '{secret}'",
                            remediation="Use strong, randomly generated secrets (256+ bits)",
                            confidence=0.99,
                            cwe_id="CWE-326",
                            cvss_score=9.1,
                        )
                        vulnerabilities.append(vuln)
                        await self._add_vulnerability(vuln)
                        break
                except Exception:
                    continue
        
        # Test 3: Algorithm confusion (RS256 -> HS256)
        if jwt.algorithm.startswith('RS') or jwt.algorithm.startswith('ES'):
            # This attack uses the public key as HMAC secret
            # We can't perform it without the public key, but we can test for it
            hs256_header = {**jwt.header, 'alg': 'HS256'}
            header_b64 = base64.urlsafe_b64encode(
                json.dumps(hs256_header).encode()
            ).rstrip(b'=').decode()
            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(jwt.payload).encode()
            ).rstrip(b'=').decode()
            
            # Try with empty signature
            confused_token = f"{header_b64}.{payload_b64}."
            status, response, _, _ = await self._make_request(
                endpoint,
                headers={"Authorization": f"Bearer {confused_token}"}
            )
            
            if status and status < 400:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.JWT_KEY_CONFUSION,
                    severity=SeverityLevel.CRITICAL,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,
                    description="JWT algorithm confusion vulnerability detected",
                    evidence="Server accepted RS256 token re-signed as HS256",
                    remediation="Validate algorithm explicitly, don't rely on header",
                    confidence=0.9,
                    cwe_id="CWE-327",
                    cvss_score=9.0,
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        # Test 4: Expired token acceptance
        if jwt.expiry and jwt.expiry < datetime.now():
            status, response, _, _ = await self._make_request(
                endpoint,
                headers={"Authorization": f"Bearer {token}"}
            )
            
            if status and status < 400:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.JWT_EXPIRED_ACCEPTED,
                    severity=SeverityLevel.HIGH,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,
                    description="Expired JWT token accepted",
                    evidence=f"Token expired at {jwt.expiry}, but still accepted",
                    remediation="Strictly validate exp claim on all requests",
                    confidence=0.95,
                    cwe_id="CWE-613",
                    cvss_score=7.5,
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        # Test 5: Claim manipulation (privilege escalation)
        priv_payloads = [
            {"role": "admin"},
            {"admin": True},
            {"is_admin": True},
            {"privilege": "admin"},
            {"user_type": "administrator"},
        ]
        
        for priv_update in priv_payloads:
            modified_jwt = jwt.modify_payload(priv_update)
            if jwt.algorithm.startswith('HS'):
                # Try common secrets
                for secret in ["secret", "key"]:
                    try:
                        mod_token = modified_jwt.encode_with_secret(secret, jwt.algorithm)
                        status, response, _, _ = await self._make_request(
                            endpoint,
                            headers={"Authorization": f"Bearer {mod_token}"}
                        )
                        
                        if status and status < 400:
                            # Check if response indicates elevated privileges
                            if response and any(
                                indicator in response.lower() 
                                for indicator in ['admin', 'privilege', 'elevated']
                            ):
                                vuln = APIVulnerability(
                                    vuln_type=APIVulnType.BFLA,
                                    severity=SeverityLevel.CRITICAL,
                                    endpoint=endpoint,
                                    method=HTTPMethod.GET,
                                    description=f"JWT claim manipulation grants elevated access",
                                    evidence=f"Modified claim {priv_update} accepted",
                                    remediation="Validate JWT claims server-side, don't trust client",
                                    confidence=0.85,
                                    cwe_id="CWE-269",
                                )
                                vulnerabilities.append(vuln)
                                await self._add_vulnerability(vuln)
                    except Exception:
                        continue
        
        return vulnerabilities
    
    # =========================================================================
    # BOLA/BFLA TESTING
    # =========================================================================
    
    async def test_bola(
        self,
        endpoint_template: str,
        own_id: str,
        other_ids: List[str],
        method: HTTPMethod = HTTPMethod.GET,
        auth_token: Optional[str] = None,
    ) -> List[APIVulnerability]:
        """
        Test for Broken Object Level Authorization (BOLA/IDOR)
        
        Args:
            endpoint_template: URL with {id} placeholder
            own_id: Current user's resource ID
            other_ids: Other users' resource IDs to test access
            method: HTTP method to test
            auth_token: Authentication token
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("BOLA testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing BOLA on {endpoint_template}")
        
        # First, get legitimate response
        own_url = endpoint_template.replace("{id}", str(own_id))
        own_status, own_response, _, _ = await self._make_request(
            own_url, method=method.value, auth_token=auth_token
        )
        
        if not own_status or own_status >= 400:
            logger.debug(f"Cannot access own resource: {own_status}")
            return vulnerabilities
        
        # Test access to other users' resources
        for other_id in other_ids:
            other_url = endpoint_template.replace("{id}", str(other_id))
            other_status, other_response, _, _ = await self._make_request(
                other_url, method=method.value, auth_token=auth_token
            )
            
            self.stats['bola_tests'] += 1
            
            if other_status and other_status < 400:
                # Check if we got actual data (not just a 200 with error)
                try:
                    other_data = json.loads(other_response) if other_response else {}
                    own_data = json.loads(own_response) if own_response else {}
                    
                    # Compare structures to verify we got different user's data
                    if other_data and other_data != own_data:
                        vuln = APIVulnerability(
                            vuln_type=APIVulnType.BOLA,
                            severity=SeverityLevel.CRITICAL,
                            endpoint=endpoint_template,
                            method=method,
                            description=f"BOLA: Accessed resource {other_id} belonging to another user",
                            evidence=f"Own ID: {own_id}, Accessed ID: {other_id}, Status: {other_status}",
                            parameter="id",
                            remediation="Implement proper authorization checks on all resource access",
                            confidence=0.95,
                            cwe_id="CWE-639",
                            cvss_score=8.6,
                        )
                        vulnerabilities.append(vuln)
                        await self._add_vulnerability(vuln)
                except json.JSONDecodeError:
                    # Non-JSON response might still be vulnerable
                    if other_response and len(other_response) > 100:
                        vuln = APIVulnerability(
                            vuln_type=APIVulnType.BOLA,
                            severity=SeverityLevel.HIGH,
                            endpoint=endpoint_template,
                            method=method,
                            description=f"Possible BOLA: Got response for resource {other_id}",
                            evidence=f"Status: {other_status}, Response length: {len(other_response)}",
                            parameter="id",
                            remediation="Verify authorization on all resource access",
                            confidence=0.7,
                            cwe_id="CWE-639",
                        )
                        vulnerabilities.append(vuln)
                        await self._add_vulnerability(vuln)
        
        # Test numeric ID manipulation
        if own_id.isdigit():
            test_ids = [
                str(int(own_id) - 1),
                str(int(own_id) + 1),
                "0",
                "1",
                "-1",
                str(int(own_id) * 2),
            ]
            
            for test_id in test_ids:
                if test_id in other_ids:
                    continue
                    
                test_url = endpoint_template.replace("{id}", test_id)
                status, response, _, _ = await self._make_request(
                    test_url, method=method.value, auth_token=auth_token
                )
                
                if status and status < 400 and response:
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.IDOR,
                        severity=SeverityLevel.HIGH,
                        endpoint=endpoint_template,
                        method=method,
                        description=f"IDOR via ID enumeration: {test_id}",
                        evidence=f"Accessed resource with manipulated ID: {test_id}",
                        parameter="id",
                        remediation="Use UUIDs instead of sequential IDs, validate authorization",
                        confidence=0.8,
                        cwe_id="CWE-639",
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    async def test_bfla(
        self,
        admin_endpoints: List[str],
        low_priv_token: str,
        methods: List[HTTPMethod] = None,
    ) -> List[APIVulnerability]:
        """
        Test for Broken Function Level Authorization (BFLA)
        
        Args:
            admin_endpoints: List of admin/privileged endpoints
            low_priv_token: Token for low-privilege user
            methods: HTTP methods to test
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("BFLA testing requires authorization")
            return vulnerabilities
        
        if methods is None:
            methods = [HTTPMethod.GET, HTTPMethod.POST, HTTPMethod.PUT, HTTPMethod.DELETE]
        
        logger.info(f"Testing BFLA on {len(admin_endpoints)} endpoints")
        
        for endpoint in admin_endpoints:
            for method in methods:
                status, response, headers, _ = await self._make_request(
                    endpoint,
                    method=method.value,
                    auth_token=low_priv_token,
                )
                
                self.stats['bfla_tests'] += 1
                
                if status and status < 400:
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.BFLA,
                        severity=SeverityLevel.CRITICAL,
                        endpoint=endpoint,
                        method=method,
                        description=f"Low-privilege user can access admin endpoint",
                        evidence=f"Endpoint: {endpoint}, Method: {method.value}, Status: {status}",
                        remediation="Implement role-based access control on all sensitive endpoints",
                        confidence=0.9,
                        cwe_id="CWE-285",
                        cvss_score=8.1,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # GRAPHQL SECURITY TESTING
    # =========================================================================
    
    async def test_graphql_security(self, endpoint: str) -> List[APIVulnerability]:
        """
        Comprehensive GraphQL security testing
        
        Tests:
        - Introspection enabled
        - Batching attacks
        - Query depth attacks
        - Field suggestion exploitation
        - Injection attacks
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("GraphQL testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing GraphQL security on {endpoint}")
        
        # Test 1: Introspection query
        introspection_query = {
            "query": """
                query IntrospectionQuery {
                    __schema {
                        types {
                            name
                            fields {
                                name
                                type { name }
                            }
                        }
                        queryType { name }
                        mutationType { name }
                    }
                }
            """
        }
        
        status, response, _, _ = await self._make_request(
            endpoint,
            method="POST",
            json_data=introspection_query,
            headers={"Content-Type": "application/json"}
        )
        
        if status == 200 and response:
            try:
                data = json.loads(response)
                if data.get('data', {}).get('__schema'):
                    schema = data['data']['__schema']
                    type_count = len(schema.get('types', []))
                    
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.GRAPHQL_INTROSPECTION,
                        severity=SeverityLevel.MEDIUM,
                        endpoint=endpoint,
                        method=HTTPMethod.POST,
                        description="GraphQL introspection enabled - full schema exposed",
                        evidence=f"Schema exposed with {type_count} types",
                        remediation="Disable introspection in production",
                        confidence=1.0,
                        cwe_id="CWE-200",
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
            except json.JSONDecodeError:
                pass
        
        # Test 2: Batching attack
        batch_query = [
            {"query": "{ __typename }"},
            {"query": "{ __typename }"},
            {"query": "{ __typename }"},
        ] * 100  # 300 queries
        
        status, response, _, response_time = await self._make_request(
            endpoint,
            method="POST",
            json_data=batch_query,
            headers={"Content-Type": "application/json"}
        )
        
        if status == 200:
            try:
                data = json.loads(response)
                if isinstance(data, list) and len(data) > 50:
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.GRAPHQL_BATCHING,
                        severity=SeverityLevel.MEDIUM,
                        endpoint=endpoint,
                        method=HTTPMethod.POST,
                        description="GraphQL batching allowed - potential DoS vector",
                        evidence=f"Server processed {len(data)} batched queries in {response_time:.2f}s",
                        remediation="Implement query batching limits",
                        confidence=0.9,
                        cwe_id="CWE-770",
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
            except json.JSONDecodeError:
                pass
        
        # Test 3: Depth attack
        depth_query = {
            "query": """
                {
                    __schema {
                        types {
                            fields {
                                type {
                                    fields {
                                        type {
                                            fields {
                                                type {
                                                    fields {
                                                        type {
                                                            name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            """
        }
        
        status, response, _, response_time = await self._make_request(
            endpoint,
            method="POST",
            json_data=depth_query,
            headers={"Content-Type": "application/json"}
        )
        
        if status == 200 and response_time > 2.0:
            vuln = APIVulnerability(
                vuln_type=APIVulnType.GRAPHQL_DEPTH,
                severity=SeverityLevel.MEDIUM,
                endpoint=endpoint,
                method=HTTPMethod.POST,
                description="GraphQL depth attack possible - no query depth limit",
                evidence=f"Deep nested query executed in {response_time:.2f}s",
                remediation="Implement query depth limits (recommend max 10)",
                confidence=0.85,
                cwe_id="CWE-770",
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        
        # Test 4: GraphQL injection
        injection_payloads = [
            '{ user(id: "1 OR 1=1") { name } }',
            '{ user(id: "1\' OR \'1\'=\'1") { name } }',
            '{ user(id: "1; DROP TABLE users;--") { name } }',
        ]
        
        for payload in injection_payloads:
            status, response, _, _ = await self._make_request(
                endpoint,
                method="POST",
                json_data={"query": payload},
                headers={"Content-Type": "application/json"}
            )
            
            if response and any(
                err in response.lower() 
                for err in ['sql', 'syntax', 'error', 'exception', 'mysql', 'postgres']
            ):
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.GRAPHQL_INJECTION,
                    severity=SeverityLevel.CRITICAL,
                    endpoint=endpoint,
                    method=HTTPMethod.POST,
                    description="GraphQL injection vulnerability",
                    evidence=f"SQL error triggered with: {payload[:50]}",
                    payload=payload,
                    remediation="Use parameterized queries, sanitize all inputs",
                    confidence=0.9,
                    cwe_id="CWE-89",
                    cvss_score=9.8,
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
                break
        
        return vulnerabilities
    
    # =========================================================================
    # OAUTH SECURITY TESTING
    # =========================================================================
    
    async def test_oauth_security(
        self,
        auth_endpoint: str,
        token_endpoint: str,
        client_id: str,
        redirect_uri: str,
    ) -> List[APIVulnerability]:
        """
        Test OAuth/OIDC security
        
        Tests:
        - Open redirect in redirect_uri
        - Token leakage
        - CSRF vulnerabilities
        - State parameter validation
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("OAuth testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing OAuth security on {auth_endpoint}")
        
        # Test 1: Open redirect in redirect_uri
        evil_redirects = [
            "https://evil.com",
            "https://evil.com/callback",
            f"https://evil.com@{urllib.parse.urlparse(redirect_uri).netloc}",
            f"{redirect_uri}/../../../evil.com",
            f"{redirect_uri}%2f%2fevil.com",
            f"{redirect_uri}?next=https://evil.com",
            f"https://{urllib.parse.urlparse(redirect_uri).netloc}.evil.com",
        ]
        
        for evil_uri in evil_redirects:
            test_url = f"{auth_endpoint}?client_id={client_id}&redirect_uri={urllib.parse.quote(evil_uri)}&response_type=code"
            
            status, response, headers, _ = await self._make_request(
                test_url,
                allow_redirects=False,
            )
            
            if status and status in [301, 302, 303, 307, 308]:
                location = headers.get('Location', headers.get('location', ''))
                if 'evil.com' in location:
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.OAUTH_REDIRECT,
                        severity=SeverityLevel.HIGH,
                        endpoint=auth_endpoint,
                        method=HTTPMethod.GET,
                        description="OAuth open redirect - token theft possible",
                        evidence=f"Redirected to: {location}",
                        payload=evil_uri,
                        parameter="redirect_uri",
                        remediation="Strictly validate redirect_uri against whitelist",
                        confidence=0.95,
                        cwe_id="CWE-601",
                        cvss_score=7.4,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
                    break
        
        # Test 2: Missing state parameter
        test_url = f"{auth_endpoint}?client_id={client_id}&redirect_uri={redirect_uri}&response_type=code"
        status, response, headers, _ = await self._make_request(test_url, allow_redirects=False)
        
        if status and status in [301, 302, 303, 307, 308]:
            location = headers.get('Location', headers.get('location', ''))
            if 'code=' in location and 'state=' not in location:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.OAUTH_CSRF,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=auth_endpoint,
                    method=HTTPMethod.GET,
                    description="OAuth CSRF - state parameter not required",
                    evidence="Authorization succeeded without state parameter",
                    remediation="Require and validate state parameter",
                    confidence=0.85,
                    cwe_id="CWE-352",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        # Test 3: Token in URL fragment (implicit flow leak)
        test_url = f"{auth_endpoint}?client_id={client_id}&redirect_uri={redirect_uri}&response_type=token"
        status, response, headers, _ = await self._make_request(test_url, allow_redirects=False)
        
        if status and status in [301, 302, 303, 307, 308]:
            location = headers.get('Location', headers.get('location', ''))
            if '#access_token=' in location:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.OAUTH_TOKEN_LEAK,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=auth_endpoint,
                    method=HTTPMethod.GET,
                    description="OAuth implicit flow enabled - token exposed in URL",
                    evidence="Access token returned in URL fragment",
                    remediation="Use authorization code flow with PKCE",
                    confidence=0.9,
                    cwe_id="CWE-522",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # RATE LIMITING BYPASS
    # =========================================================================
    
    async def test_rate_limit_bypass(
        self,
        endpoint: str,
        requests_count: int = 100,
        method: HTTPMethod = HTTPMethod.GET,
    ) -> List[APIVulnerability]:
        """
        Test rate limiting implementation and bypass techniques
        
        Tests:
        - Basic rate limiting presence
        - Header manipulation bypass (X-Forwarded-For)
        - Case variation bypass
        - Parameter pollution bypass
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("Rate limit testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing rate limits on {endpoint}")
        
        # Test 1: Basic rate limiting
        success_count = 0
        rate_limited = False
        
        for i in range(min(requests_count, 50)):
            status, _, _, _ = await self._make_request(endpoint, method=method.value)
            if status and status < 400:
                success_count += 1
            elif status == 429:
                rate_limited = True
                break
            await asyncio.sleep(0.1)  # Small delay
        
        if not rate_limited and success_count >= 50:
            vuln = APIVulnerability(
                vuln_type=APIVulnType.RATE_LIMIT_BYPASS,
                severity=SeverityLevel.MEDIUM,
                endpoint=endpoint,
                method=method,
                description="No rate limiting detected - abuse possible",
                evidence=f"Successfully made {success_count} requests without rate limiting",
                remediation="Implement rate limiting (recommend 100 requests/minute)",
                confidence=0.85,
                cwe_id="CWE-770",
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        
        # Test 2: X-Forwarded-For bypass
        bypass_headers = [
            {"X-Forwarded-For": f"192.168.1.{random.randint(1, 254)}"},
            {"X-Real-IP": f"10.0.0.{random.randint(1, 254)}"},
            {"X-Client-IP": f"172.16.0.{random.randint(1, 254)}"},
            {"X-Originating-IP": f"192.168.{random.randint(1, 254)}.1"},
            {"True-Client-IP": f"10.{random.randint(1, 254)}.0.1"},
        ]
        
        for bypass_header in bypass_headers:
            success_count = 0
            for i in range(20):
                # Randomize IP for each request
                for key in bypass_header:
                    bypass_header[key] = f"{random.randint(1, 254)}.{random.randint(1, 254)}.{random.randint(1, 254)}.{random.randint(1, 254)}"
                
                status, _, _, _ = await self._make_request(
                    endpoint, method=method.value, headers=bypass_header
                )
                if status and status < 400:
                    success_count += 1
                elif status == 429:
                    break
            
            if success_count >= 20:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.RATE_LIMIT_BYPASS,
                    severity=SeverityLevel.HIGH,
                    endpoint=endpoint,
                    method=method,
                    description=f"Rate limit bypass via {list(bypass_header.keys())[0]} header",
                    evidence=f"Made {success_count} requests using IP header rotation",
                    payload=str(bypass_header),
                    remediation="Don't trust client-provided IP headers for rate limiting",
                    confidence=0.9,
                    cwe_id="CWE-770",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
                break
        
        return vulnerabilities
    
    # =========================================================================
    # MASS ASSIGNMENT TESTING
    # =========================================================================
    
    async def test_mass_assignment(
        self,
        endpoint: str,
        original_data: Dict[str, Any],
        method: HTTPMethod = HTTPMethod.POST,
    ) -> List[APIVulnerability]:
        """
        Test for mass assignment vulnerabilities
        
        Args:
            endpoint: API endpoint
            original_data: Original request data
            method: HTTP method
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("Mass assignment testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing mass assignment on {endpoint}")
        
        for dangerous_field in self.MASS_ASSIGNMENT_FIELDS:
            # Test with different dangerous values
            test_values = [True, "admin", 1, "administrator"]
            
            for test_value in test_values:
                test_data = {**original_data, dangerous_field: test_value}
                
                status, response, _, _ = await self._make_request(
                    endpoint,
                    method=method.value,
                    json_data=test_data,
                    headers={"Content-Type": "application/json"}
                )
                
                self.stats['mass_assignment_tests'] += 1
                
                if status and status < 400 and response:
                    try:
                        resp_data = json.loads(response)
                        # Check if the dangerous field was accepted
                        if dangerous_field in str(resp_data):
                            vuln = APIVulnerability(
                                vuln_type=APIVulnType.MASS_ASSIGNMENT,
                                severity=SeverityLevel.HIGH,
                                endpoint=endpoint,
                                method=method,
                                description=f"Mass assignment: '{dangerous_field}' field accepted",
                                evidence=f"Field '{dangerous_field}={test_value}' included in response",
                                parameter=dangerous_field,
                                payload=json.dumps({dangerous_field: test_value}),
                                remediation="Use explicit allowlist for accepted fields",
                                confidence=0.8,
                                cwe_id="CWE-915",
                            )
                            vulnerabilities.append(vuln)
                            await self._add_vulnerability(vuln)
                            break
                    except json.JSONDecodeError:
                        continue
        
        return vulnerabilities
    
    # =========================================================================
    # HTTP VERB TAMPERING
    # =========================================================================
    
    async def test_verb_tampering(self, endpoint: str) -> List[APIVulnerability]:
        """
        Test for HTTP verb tampering vulnerabilities
        
        Tests unauthorized access via different HTTP methods
        """
        vulnerabilities = []
        
        if not self._check_authorization():
            logger.warning("Verb tampering testing requires authorization")
            return vulnerabilities
        
        logger.info(f"Testing verb tampering on {endpoint}")
        
        methods_to_test = [
            "GET", "POST", "PUT", "PATCH", "DELETE",
            "OPTIONS", "HEAD", "TRACE", "CONNECT",
            "PROPFIND", "PROPPATCH", "MKCOL", "COPY",
            "MOVE", "LOCK", "UNLOCK",
        ]
        
        allowed_methods = []
        
        for method in methods_to_test:
            status, response, headers, _ = await self._make_request(
                endpoint, method=method
            )
            
            self.stats['verb_tests'] += 1
            
            if status and status < 400:
                allowed_methods.append(method)
            
            # Check for dangerous methods
            if method == "TRACE" and status and status < 400:
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.VERB_TAMPERING,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,  # Use GET as placeholder
                    description="TRACE method enabled - XST attack possible",
                    evidence=f"TRACE returned status {status}",
                    remediation="Disable TRACE method on server",
                    confidence=0.95,
                    cwe_id="CWE-693",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
            
            if method in ["PUT", "DELETE", "PATCH"] and status and status < 400:
                # Test if authentication is bypassed
                status_no_auth, _, _, _ = await self._make_request(
                    endpoint, method=method, auth_token=None
                )
                
                if status_no_auth and status_no_auth < 400:
                    vuln = APIVulnerability(
                        vuln_type=APIVulnType.VERB_TAMPERING,
                        severity=SeverityLevel.HIGH,
                        endpoint=endpoint,
                        method=HTTPMethod[method] if method in HTTPMethod.__members__ else HTTPMethod.GET,
                        description=f"{method} method accessible without authentication",
                        evidence=f"Unauthenticated {method} returned {status_no_auth}",
                        remediation="Require authentication for all state-changing methods",
                        confidence=0.9,
                        cwe_id="CWE-287",
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # CORS TESTING
    # =========================================================================
    
    async def test_cors_configuration(self, endpoint: str) -> List[APIVulnerability]:
        """
        Test CORS configuration for misconfigurations
        """
        vulnerabilities = []
        
        logger.info(f"Testing CORS on {endpoint}")
        
        # Test 1: Wildcard origin
        status, _, headers, _ = await self._make_request(
            endpoint,
            headers={"Origin": "https://evil.com"}
        )
        
        if headers:
            acao = headers.get('Access-Control-Allow-Origin', headers.get('access-control-allow-origin', ''))
            acac = headers.get('Access-Control-Allow-Credentials', headers.get('access-control-allow-credentials', ''))
            
            if acao == '*':
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.CORS_MISCONFIG,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,
                    description="CORS wildcard origin allowed",
                    evidence=f"Access-Control-Allow-Origin: *",
                    remediation="Restrict CORS to trusted domains",
                    confidence=1.0,
                    cwe_id="CWE-942",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
            
            if acao == 'https://evil.com':
                severity = SeverityLevel.HIGH if acac.lower() == 'true' else SeverityLevel.MEDIUM
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.CORS_MISCONFIG,
                    severity=severity,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,
                    description="CORS reflects arbitrary origin" + (" with credentials" if acac.lower() == 'true' else ""),
                    evidence=f"Origin 'https://evil.com' reflected in ACAO header",
                    remediation="Validate origin against whitelist",
                    confidence=0.95,
                    cwe_id="CWE-942",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        # Test 2: Null origin
        status, _, headers, _ = await self._make_request(
            endpoint,
            headers={"Origin": "null"}
        )
        
        if headers:
            acao = headers.get('Access-Control-Allow-Origin', headers.get('access-control-allow-origin', ''))
            if acao == 'null':
                vuln = APIVulnerability(
                    vuln_type=APIVulnType.CORS_MISCONFIG,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    method=HTTPMethod.GET,
                    description="CORS allows null origin",
                    evidence="Access-Control-Allow-Origin: null",
                    remediation="Don't allow null origin",
                    confidence=0.95,
                    cwe_id="CWE-942",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # MAIN SCAN METHODS
    # =========================================================================
    
    async def scan(self, config: Optional[APISecurityConfig] = None) -> List[APIVulnerability]:
        """
        Run comprehensive API security scan
        
        Args:
            config: API security configuration
            
        Returns:
            List of discovered vulnerabilities
        """
        if config:
            self.config = config
        
        if not self.config:
            logger.error("No configuration provided")
            return []
        
        if not self._check_authorization():
            logger.error("Testing not authorized. Call authorize() first.")
            return []
        
        self._running = True
        self.vulnerabilities = []
        
        logger.info(f"Starting API security scan on: {self.config.base_url}")
        
        try:
            tasks = []
            
            # JWT Testing
            if self.config.test_jwt and self.config.auth_token:
                try:
                    JWTToken.decode(self.config.auth_token)
                    for endpoint in self.config.endpoints:
                        full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                        tasks.append(self.test_jwt_security(self.config.auth_token, full_url))
                except Exception:
                    pass  # Not a JWT token
            
            # BOLA Testing
            if self.config.test_bola and self.config.other_user_ids:
                for endpoint in self.config.endpoints:
                    if '{id}' in endpoint:
                        full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                        tasks.append(self.test_bola(
                            full_url,
                            self.config.other_user_ids[0] if self.config.other_user_ids else "1",
                            self.config.other_user_ids[1:] if len(self.config.other_user_ids) > 1 else ["2", "3"],
                            auth_token=self.config.auth_token,
                        ))
            
            # BFLA Testing
            if self.config.test_bfla and self.config.low_priv_token:
                admin_endpoints = [e for e in self.config.endpoints if 'admin' in e.lower()]
                if admin_endpoints:
                    tasks.append(self.test_bfla(
                        [f"{self.config.base_url.rstrip('/')}/{e.lstrip('/')}" for e in admin_endpoints],
                        self.config.low_priv_token,
                    ))
            
            # GraphQL Testing
            if self.config.test_graphql:
                graphql_endpoints = [e for e in self.config.endpoints if 'graphql' in e.lower()]
                for endpoint in graphql_endpoints:
                    full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                    tasks.append(self.test_graphql_security(full_url))
            
            # Rate Limit Testing
            if self.config.test_rate_limits:
                for endpoint in self.config.endpoints[:3]:  # Test first 3 endpoints
                    full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                    tasks.append(self.test_rate_limit_bypass(full_url))
            
            # Verb Tampering Testing
            if self.config.test_verb_tampering:
                for endpoint in self.config.endpoints:
                    full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                    tasks.append(self.test_verb_tampering(full_url))
            
            # CORS Testing
            for endpoint in self.config.endpoints:
                full_url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
                tasks.append(self.test_cors_configuration(full_url))
            
            # Run all tasks with concurrency limit
            semaphore = asyncio.Semaphore(self.config.max_concurrent)
            
            async def limited_task(task):
                async with semaphore:
                    return await task
            
            await asyncio.gather(*[limited_task(t) for t in tasks], return_exceptions=True)
            
        except Exception as e:
            logger.error(f"Scan error: {e}")
        finally:
            self._running = False
        
        logger.info(f"Scan complete. Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities
    
    def get_stats(self) -> Dict[str, Any]:
        """Get scan statistics"""
        return {
            'requests': self.stats['requests'],
            'vulnerabilities': self.stats['vulnerabilities'],
            'timeouts': self.stats['timeouts'],
            'errors': self.stats['errors'],
            'tests': {
                'jwt': self.stats.get('jwt_tests', 0),
                'bola': self.stats.get('bola_tests', 0),
                'bfla': self.stats.get('bfla_tests', 0),
                'graphql': self.stats.get('graphql_tests', 0),
                'rate_limit': self.stats.get('rate_limit_tests', 0),
                'mass_assignment': self.stats.get('mass_assignment_tests', 0),
                'verb_tampering': self.stats.get('verb_tests', 0),
            }
        }
    
    def get_report(self, format: str = "json") -> str:
        """
        Generate security report
        
        Args:
            format: Report format (json, text)
        """
        if format == "json":
            report = {
                'target': self.config.base_url if self.config else None,
                'scan_time': datetime.now().isoformat(),
                'statistics': self.get_stats(),
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }
            return json.dumps(report, indent=2)
        
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - API SECURITY SCAN REPORT",
                "=" * 70,
                f"Target: {self.config.base_url if self.config else 'N/A'}",
                f"Scan Time: {datetime.now().isoformat()}",
                "",
                "SUMMARY:",
                f"  Total Vulnerabilities: {len(self.vulnerabilities)}",
                f"  Critical: {sum(1 for v in self.vulnerabilities if v.severity == SeverityLevel.CRITICAL)}",
                f"  High: {sum(1 for v in self.vulnerabilities if v.severity == SeverityLevel.HIGH)}",
                f"  Medium: {sum(1 for v in self.vulnerabilities if v.severity == SeverityLevel.MEDIUM)}",
                f"  Low: {sum(1 for v in self.vulnerabilities if v.severity == SeverityLevel.LOW)}",
                "",
                "VULNERABILITIES:",
                "-" * 50,
            ]
            
            for vuln in sorted(self.vulnerabilities, key=lambda v: list(SeverityLevel).index(v.severity)):
                lines.append(f"\n[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  Endpoint: {vuln.endpoint}")
                lines.append(f"  Method: {vuln.method.value}")
                lines.append(f"  Description: {vuln.description}")
                if vuln.evidence:
                    lines.append(f"  Evidence: {vuln.evidence[:200]}")
                if vuln.remediation:
                    lines.append(f"  Remediation: {vuln.remediation}")
                if vuln.cwe_id:
                    lines.append(f"  CWE: {vuln.cwe_id}")
            
            lines.append("")
            lines.append("=" * 70)
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear all results from RAM (secure wipe)"""
        self.vulnerabilities = []
        self.endpoints = []
        self.stats = defaultdict(int)
        logger.info("Results cleared from RAM")
    
    def stop(self):
        """Stop running scan"""
        self._running = False


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def create_api_scanner(
    base_url: str,
    auth_token: Optional[str] = None,
    endpoints: Optional[List[str]] = None,
    proxy: Optional[str] = None,
) -> APISecurityScanner:
    """
    Factory function to create API security scanner
    
    Args:
        base_url: Target API base URL
        auth_token: Authentication token
        endpoints: List of endpoints to test
        proxy: Proxy URL for anonymity
    """
    config = APISecurityConfig(
        base_url=base_url,
        auth_token=auth_token,
        endpoints=endpoints or [],
        use_proxy=bool(proxy),
        proxy_url=proxy,
    )
    
    return APISecurityScanner(config)


async def quick_api_scan(
    base_url: str,
    auth_token: Optional[str] = None,
    endpoints: Optional[List[str]] = None,
) -> List[APIVulnerability]:
    """
    Quick API security scan with default settings
    
    Args:
        base_url: Target API base URL
        auth_token: Authentication token
        endpoints: List of endpoints to test
    """
    scanner = create_api_scanner(base_url, auth_token, endpoints)
    scanner.authorize("I_AUTHORIZE_API_TESTING")
    return await scanner.scan()


# =============================================================================
# MODULE INFO
# =============================================================================

__all__ = [
    # Main classes
    'APISecurityScanner',
    'APISecurityConfig',
    'APIVulnerability',
    'JWTToken',
    'APIEndpoint',
    # Enums
    'APIVulnType',
    'SeverityLevel',
    'AuthType',
    'HTTPMethod',
    # Convenience functions
    'create_api_scanner',
    'quick_api_scan',
]

__version__ = '1.0.0'
__author__ = 'RF Arsenal Security Team'


if __name__ == "__main__":
    import sys
    
    logging.basicConfig(level=logging.INFO)
    
    async def main():
        print("RF Arsenal OS - API Security Scanner")
        print("=" * 50)
        
        # Example: Test JWT
        if len(sys.argv) > 1:
            token = sys.argv[1]
            try:
                jwt = JWTToken.decode(token)
                print(f"\nJWT Analysis:")
                print(f"  Algorithm: {jwt.algorithm}")
                print(f"  Issuer: {jwt.issuer}")
                print(f"  Subject: {jwt.subject}")
                print(f"  Expiry: {jwt.expiry}")
                print(f"  Claims: {list(jwt.payload.keys())}")
            except Exception as e:
                print(f"Failed to decode JWT: {e}")
        else:
            print("\nUsage: python api_security.py <jwt_token>")
            print("\nCapabilities:")
            print("  - JWT security testing (none alg, weak secrets, confusion)")
            print("  - BOLA/BFLA testing (access control)")
            print("  - GraphQL security (introspection, batching, depth)")
            print("  - OAuth/OIDC testing (redirect, CSRF, token leak)")
            print("  - Rate limit bypass detection")
            print("  - Mass assignment testing")
            print("  - HTTP verb tampering")
            print("  - CORS misconfiguration")
    
    asyncio.run(main())
