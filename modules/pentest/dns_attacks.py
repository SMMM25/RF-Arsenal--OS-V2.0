#!/usr/bin/env python3
"""
RF Arsenal OS - DNS/Domain Security Testing Module
===================================================

Professional DNS and domain security testing with stealth-first design.
Comprehensive testing for DNS misconfigurations and vulnerabilities.

CAPABILITIES:
- DNS zone transfer testing (AXFR)
- Subdomain enumeration and takeover detection
- DNS cache poisoning simulation
- Dangling DNS detection
- DNSSEC validation testing
- DNS rebinding attack preparation
- Domain hijacking risk assessment

README COMPLIANCE:
- Stealth-First: Rate-limited queries, randomized timing
- RAM-Only: All findings stored in memory only
- No Telemetry: Zero external data transmission
- Offline-First: Zone file analysis works offline

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import base64
import hashlib
import json
import logging
import os
import random
import re
import secrets
import socket
import ssl
import struct
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

# Optional dependencies with graceful fallback
try:
    import dns.resolver
    import dns.query
    import dns.zone
    import dns.rdatatype
    import dns.name
    import dns.message
    import dns.flags
    DNS_AVAILABLE = True
except ImportError:
    DNS_AVAILABLE = False

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS AND DATA CLASSES
# =============================================================================

class DNSVulnType(Enum):
    """DNS vulnerability types"""
    ZONE_TRANSFER = "zone_transfer_enabled"
    SUBDOMAIN_TAKEOVER = "subdomain_takeover"
    DANGLING_CNAME = "dangling_cname"
    DANGLING_NS = "dangling_ns"
    DNSSEC_DISABLED = "dnssec_disabled"
    DNSSEC_MISCONFIGURED = "dnssec_misconfigured"
    OPEN_RESOLVER = "open_dns_resolver"
    DNS_AMPLIFICATION = "dns_amplification"
    CACHE_POISONING = "dns_cache_poisoning_risk"
    WILDCARD_DNS = "wildcard_dns"
    SPF_MISSING = "spf_missing"
    SPF_PERMISSIVE = "spf_too_permissive"
    DMARC_MISSING = "dmarc_missing"
    DMARC_PERMISSIVE = "dmarc_too_permissive"
    DKIM_MISSING = "dkim_missing"
    MX_SECURITY = "mx_security_issue"
    NS_SINGLE_PROVIDER = "ns_single_provider"
    OLD_DNS_SOFTWARE = "outdated_dns_software"
    EXPOSED_VERSION = "dns_version_exposed"
    DOMAIN_FRONTING = "domain_fronting_possible"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


class RecordType(Enum):
    """DNS record types"""
    A = "A"
    AAAA = "AAAA"
    CNAME = "CNAME"
    MX = "MX"
    NS = "NS"
    TXT = "TXT"
    SOA = "SOA"
    PTR = "PTR"
    SRV = "SRV"
    CAA = "CAA"
    DNSKEY = "DNSKEY"
    DS = "DS"
    RRSIG = "RRSIG"
    NSEC = "NSEC"
    NSEC3 = "NSEC3"
    ANY = "ANY"


@dataclass
class DNSVulnerability:
    """Detected DNS vulnerability"""
    vuln_type: DNSVulnType
    severity: SeverityLevel
    domain: str
    record_type: Optional[RecordType] = None
    description: str = ""
    evidence: Optional[str] = None
    affected_records: List[str] = field(default_factory=list)
    remediation: str = ""
    confidence: float = 0.0
    cwe_id: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for reporting"""
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'domain': self.domain,
            'record_type': self.record_type.value if self.record_type else None,
            'description': self.description,
            'evidence': self.evidence[:1000] if self.evidence else None,
            'affected_records': self.affected_records[:10],
            'remediation': self.remediation,
            'confidence': self.confidence,
            'cwe_id': self.cwe_id,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class DNSRecord:
    """DNS record information"""
    name: str
    record_type: RecordType
    value: str
    ttl: int = 0
    priority: Optional[int] = None  # For MX records


@dataclass
class Subdomain:
    """Discovered subdomain"""
    name: str
    ip_addresses: List[str] = field(default_factory=list)
    cname: Optional[str] = None
    is_alive: bool = False
    takeover_possible: bool = False
    takeover_service: Optional[str] = None
    http_status: Optional[int] = None
    title: Optional[str] = None


@dataclass
class DNSSecurityConfig:
    """DNS security testing configuration"""
    # Target
    target_domain: str
    
    # Subdomain enumeration
    subdomain_wordlist: List[str] = field(default_factory=list)
    max_subdomains: int = 1000
    enumerate_subdomains: bool = True
    
    # Test modules
    test_zone_transfer: bool = True
    test_subdomain_takeover: bool = True
    test_dnssec: bool = True
    test_email_security: bool = True
    test_cache_poisoning: bool = True
    
    # Stealth settings
    delay_min: float = 0.1
    delay_max: float = 0.5
    randomize_timing: bool = True
    use_proxy_dns: bool = False
    dns_servers: List[str] = field(default_factory=lambda: ["8.8.8.8", "1.1.1.1"])
    
    # Limits
    timeout: float = 5.0
    max_concurrent: int = 50


# =============================================================================
# DNS SECURITY SCANNER
# =============================================================================

class DNSSecurityScanner:
    """
    Professional DNS Security Scanner
    
    Capabilities:
    - Zone transfer testing
    - Subdomain enumeration
    - Takeover detection
    - DNSSEC validation
    - Email security (SPF/DKIM/DMARC)
    
    README COMPLIANCE:
    - Stealth-First: Rate-limited, randomized
    - RAM-Only: No persistent storage
    - No Telemetry: Zero external reporting
    - Authorization Required: Explicit consent
    """
    
    # Common subdomains for enumeration
    COMMON_SUBDOMAINS = [
        "www", "mail", "ftp", "smtp", "pop", "imap", "webmail",
        "admin", "administrator", "root", "test", "dev", "staging",
        "api", "app", "apps", "mobile", "m", "beta", "alpha",
        "portal", "secure", "login", "auth", "sso", "vpn",
        "ns1", "ns2", "ns3", "dns", "dns1", "dns2",
        "mx", "mx1", "mx2", "email", "mail2", "smtp2",
        "cdn", "static", "assets", "media", "images", "img",
        "db", "database", "mysql", "postgres", "sql", "redis",
        "git", "gitlab", "github", "bitbucket", "svn",
        "ci", "jenkins", "build", "deploy", "docker",
        "monitoring", "grafana", "prometheus", "nagios", "zabbix",
        "logs", "elk", "kibana", "elasticsearch", "logstash",
        "backup", "bak", "old", "new", "temp", "tmp",
        "shop", "store", "cart", "pay", "payment", "checkout",
        "blog", "news", "forum", "community", "support", "help",
        "docs", "documentation", "wiki", "kb", "knowledge",
        "status", "health", "ping", "metrics", "stats",
        "internal", "intranet", "extranet", "corp", "corporate",
        "hr", "finance", "legal", "sales", "marketing",
        "aws", "azure", "gcp", "cloud", "k8s", "kubernetes",
        "stage", "uat", "qa", "preprod", "prod", "production",
        "sandbox", "demo", "preview", "canary",
    ]
    
    # Services vulnerable to subdomain takeover
    TAKEOVER_SIGNATURES = {
        "github.io": {
            "cname_pattern": r"\.github\.io$",
            "fingerprint": "There isn't a GitHub Pages site here",
            "service": "GitHub Pages",
        },
        "herokuapp.com": {
            "cname_pattern": r"\.herokuapp\.com$",
            "fingerprint": "no such app",
            "service": "Heroku",
        },
        "s3.amazonaws.com": {
            "cname_pattern": r"\.s3\.amazonaws\.com$|\.s3-[a-z0-9-]+\.amazonaws\.com$",
            "fingerprint": "NoSuchBucket",
            "service": "AWS S3",
        },
        "cloudfront.net": {
            "cname_pattern": r"\.cloudfront\.net$",
            "fingerprint": "Bad Request",
            "service": "AWS CloudFront",
        },
        "azurewebsites.net": {
            "cname_pattern": r"\.azurewebsites\.net$",
            "fingerprint": "404 Web Site not found",
            "service": "Azure",
        },
        "blob.core.windows.net": {
            "cname_pattern": r"\.blob\.core\.windows\.net$",
            "fingerprint": "BlobNotFound",
            "service": "Azure Blob",
        },
        "cloudapp.net": {
            "cname_pattern": r"\.cloudapp\.net$",
            "fingerprint": "404",
            "service": "Azure Cloud",
        },
        "zendesk.com": {
            "cname_pattern": r"\.zendesk\.com$",
            "fingerprint": "Help Center Closed",
            "service": "Zendesk",
        },
        "shopify.com": {
            "cname_pattern": r"\.myshopify\.com$",
            "fingerprint": "Sorry, this shop is currently unavailable",
            "service": "Shopify",
        },
        "tumblr.com": {
            "cname_pattern": r"\.tumblr\.com$",
            "fingerprint": "There's nothing here",
            "service": "Tumblr",
        },
        "wordpress.com": {
            "cname_pattern": r"\.wordpress\.com$",
            "fingerprint": "Do you want to register",
            "service": "WordPress.com",
        },
        "ghost.io": {
            "cname_pattern": r"\.ghost\.io$",
            "fingerprint": "The thing you were looking for is no longer here",
            "service": "Ghost",
        },
        "surge.sh": {
            "cname_pattern": r"\.surge\.sh$",
            "fingerprint": "project not found",
            "service": "Surge.sh",
        },
        "bitbucket.io": {
            "cname_pattern": r"\.bitbucket\.io$",
            "fingerprint": "Repository not found",
            "service": "Bitbucket",
        },
        "pantheonsite.io": {
            "cname_pattern": r"\.pantheonsite\.io$",
            "fingerprint": "404 error",
            "service": "Pantheon",
        },
        "fastly.net": {
            "cname_pattern": r"\.fastly\.net$",
            "fingerprint": "Fastly error",
            "service": "Fastly",
        },
        "netlify.app": {
            "cname_pattern": r"\.netlify\.app$|\.netlify\.com$",
            "fingerprint": "Not Found",
            "service": "Netlify",
        },
        "vercel.app": {
            "cname_pattern": r"\.vercel\.app$|\.now\.sh$",
            "fingerprint": "404",
            "service": "Vercel",
        },
        "firebaseapp.com": {
            "cname_pattern": r"\.firebaseapp\.com$|\.web\.app$",
            "fingerprint": "404",
            "service": "Firebase",
        },
    }
    
    def __init__(self, config: Optional[DNSSecurityConfig] = None):
        """Initialize DNS security scanner"""
        self.config = config
        self.vulnerabilities: List[DNSVulnerability] = []
        self.subdomains: List[Subdomain] = []
        self.dns_records: List[DNSRecord] = []
        self.stats = defaultdict(int)
        self._running = False
        self._lock = asyncio.Lock()
        self._authorized = False
        self._resolver = None
        
        if DNS_AVAILABLE:
            self._resolver = dns.resolver.Resolver()
            self._resolver.timeout = 5.0
            self._resolver.lifetime = 10.0
        
        logger.info("DNSSecurityScanner initialized - RAM-only, stealth mode")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_DNS_TESTING") -> bool:
        """Authorize DNS security testing"""
        if confirmation == "I_AUTHORIZE_DNS_TESTING":
            self._authorized = True
            logger.info("DNS security testing authorized")
            return True
        return False
    
    async def _delay(self):
        """Apply stealth delay"""
        if self.config and self.config.randomize_timing:
            delay = random.uniform(self.config.delay_min, self.config.delay_max)
            await asyncio.sleep(delay)
    
    async def _add_vulnerability(self, vuln: DNSVulnerability):
        """Add vulnerability (thread-safe)"""
        async with self._lock:
            for existing in self.vulnerabilities:
                if (existing.vuln_type == vuln.vuln_type and
                    existing.domain == vuln.domain and
                    existing.record_type == vuln.record_type):
                    return
            
            self.vulnerabilities.append(vuln)
            self.stats['vulnerabilities'] += 1
            logger.info(f"[{vuln.severity.value.upper()}] {vuln.vuln_type.value}: {vuln.domain}")
    
    def _resolve_sync(self, domain: str, record_type: str) -> List[str]:
        """Synchronous DNS resolution"""
        if not DNS_AVAILABLE:
            return []
        
        try:
            answers = self._resolver.resolve(domain, record_type)
            return [str(rdata) for rdata in answers]
        except Exception:
            return []
    
    async def _resolve(self, domain: str, record_type: str) -> List[str]:
        """Async DNS resolution wrapper"""
        await self._delay()
        self.stats['dns_queries'] += 1
        
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self._resolve_sync, domain, record_type)
    
    # =========================================================================
    # ZONE TRANSFER TESTING
    # =========================================================================
    
    async def test_zone_transfer(self, domain: str) -> List[DNSRecord]:
        """
        Test for DNS zone transfer (AXFR) vulnerability
        
        Args:
            domain: Target domain
            
        Returns:
            List of records if transfer successful
        """
        if not self._authorized:
            logger.warning("Zone transfer testing requires authorization")
            return []
        
        if not DNS_AVAILABLE:
            logger.warning("dnspython not available")
            return []
        
        logger.info(f"Testing zone transfer for {domain}")
        
        records = []
        
        # Get nameservers
        try:
            ns_records = await self._resolve(domain, 'NS')
        except Exception:
            ns_records = []
        
        if not ns_records:
            logger.debug(f"No NS records found for {domain}")
            return []
        
        # Try zone transfer from each nameserver
        for ns in ns_records:
            ns_host = ns.rstrip('.')
            
            try:
                # Attempt AXFR
                zone = dns.zone.from_xfr(
                    dns.query.xfr(ns_host, domain, timeout=10)
                )
                
                # Zone transfer successful - this is a vulnerability
                for name, node in zone.items():
                    for rdataset in node.rdatasets:
                        for rdata in rdataset:
                            record = DNSRecord(
                                name=str(name),
                                record_type=RecordType(dns.rdatatype.to_text(rdataset.rdtype)),
                                value=str(rdata),
                                ttl=rdataset.ttl,
                            )
                            records.append(record)
                            self.dns_records.append(record)
                
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.ZONE_TRANSFER,
                    severity=SeverityLevel.HIGH,
                    domain=domain,
                    description=f"DNS zone transfer (AXFR) allowed from {ns_host}",
                    evidence=f"Retrieved {len(records)} records via zone transfer",
                    affected_records=[r.name for r in records[:10]],
                    remediation="Restrict zone transfers to authorized secondary DNS servers",
                    confidence=1.0,
                    cwe_id="CWE-200",
                    metadata={'nameserver': ns_host, 'record_count': len(records)},
                )
                await self._add_vulnerability(vuln)
                
                logger.info(f"Zone transfer successful from {ns_host}: {len(records)} records")
                break
            
            except dns.query.TransferError:
                logger.debug(f"Zone transfer denied by {ns_host}")
            except dns.exception.FormError:
                logger.debug(f"Zone transfer form error from {ns_host}")
            except Exception as e:
                logger.debug(f"Zone transfer error from {ns_host}: {e}")
        
        return records
    
    # =========================================================================
    # SUBDOMAIN ENUMERATION
    # =========================================================================
    
    async def enumerate_subdomains(
        self,
        domain: str,
        wordlist: Optional[List[str]] = None,
    ) -> List[Subdomain]:
        """
        Enumerate subdomains using DNS queries
        
        Args:
            domain: Target domain
            wordlist: Custom subdomain wordlist
        """
        if not self._authorized:
            logger.warning("Subdomain enumeration requires authorization")
            return []
        
        logger.info(f"Enumerating subdomains for {domain}")
        
        words = wordlist or self.COMMON_SUBDOMAINS
        if self.config and self.config.subdomain_wordlist:
            words = list(set(words + self.config.subdomain_wordlist))
        
        # Limit wordlist
        max_words = self.config.max_subdomains if self.config else 1000
        words = words[:max_words]
        
        found_subdomains = []
        semaphore = asyncio.Semaphore(self.config.max_concurrent if self.config else 50)
        
        async def check_subdomain(subdomain_prefix: str) -> Optional[Subdomain]:
            async with semaphore:
                fqdn = f"{subdomain_prefix}.{domain}"
                
                subdomain = Subdomain(name=fqdn)
                
                # Try A record
                ips = await self._resolve(fqdn, 'A')
                if ips:
                    subdomain.ip_addresses = ips
                    subdomain.is_alive = True
                
                # Try CNAME
                cnames = await self._resolve(fqdn, 'CNAME')
                if cnames:
                    subdomain.cname = cnames[0]
                
                if subdomain.is_alive or subdomain.cname:
                    self.stats['subdomains_found'] += 1
                    return subdomain
                
                return None
        
        tasks = [check_subdomain(word) for word in words]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, Subdomain) and result:
                found_subdomains.append(result)
                self.subdomains.append(result)
        
        logger.info(f"Found {len(found_subdomains)} subdomains")
        return found_subdomains
    
    # =========================================================================
    # SUBDOMAIN TAKEOVER DETECTION
    # =========================================================================
    
    async def check_subdomain_takeover(
        self,
        subdomains: Optional[List[Subdomain]] = None,
    ) -> List[DNSVulnerability]:
        """
        Check for subdomain takeover vulnerabilities
        
        Args:
            subdomains: List of subdomains to check (uses discovered if None)
        """
        if not self._authorized:
            logger.warning("Takeover testing requires authorization")
            return []
        
        if not AIOHTTP_AVAILABLE:
            logger.warning("aiohttp not available for HTTP checks")
            return []
        
        subdomains_to_check = subdomains or self.subdomains
        vulnerabilities = []
        
        logger.info(f"Checking {len(subdomains_to_check)} subdomains for takeover")
        
        semaphore = asyncio.Semaphore(20)
        
        async def check_takeover(subdomain: Subdomain) -> Optional[DNSVulnerability]:
            async with semaphore:
                # Only check subdomains with CNAME
                if not subdomain.cname:
                    return None
                
                cname = subdomain.cname.lower().rstrip('.')
                
                # Check against known takeover signatures
                for service_domain, signature in self.TAKEOVER_SIGNATURES.items():
                    if re.search(signature['cname_pattern'], cname, re.IGNORECASE):
                        # Check if the CNAME target exists
                        try:
                            # Try HTTP request to check fingerprint
                            async with aiohttp.ClientSession() as session:
                                for protocol in ['https', 'http']:
                                    try:
                                        url = f"{protocol}://{subdomain.name}"
                                        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10), ssl=False) as response:
                                            text = await response.text()
                                            subdomain.http_status = response.status
                                            
                                            if signature['fingerprint'] in text:
                                                subdomain.takeover_possible = True
                                                subdomain.takeover_service = signature['service']
                                                
                                                vuln = DNSVulnerability(
                                                    vuln_type=DNSVulnType.SUBDOMAIN_TAKEOVER,
                                                    severity=SeverityLevel.HIGH,
                                                    domain=subdomain.name,
                                                    record_type=RecordType.CNAME,
                                                    description=f"Subdomain takeover possible via {signature['service']}",
                                                    evidence=f"CNAME: {cname}, Fingerprint matched: {signature['fingerprint'][:50]}",
                                                    remediation=f"Remove CNAME record or claim the {signature['service']} resource",
                                                    confidence=0.9,
                                                    cwe_id="CWE-284",
                                                    metadata={'service': signature['service'], 'cname': cname},
                                                )
                                                return vuln
                                            break
                                    except Exception:
                                        continue
                        
                        except Exception as e:
                            logger.debug(f"Error checking {subdomain.name}: {e}")
                            
                            # If we can't reach the CNAME target, it might be dangling
                            cname_ips = await self._resolve(cname, 'A')
                            if not cname_ips:
                                subdomain.takeover_possible = True
                                subdomain.takeover_service = signature['service']
                                
                                vuln = DNSVulnerability(
                                    vuln_type=DNSVulnType.DANGLING_CNAME,
                                    severity=SeverityLevel.HIGH,
                                    domain=subdomain.name,
                                    record_type=RecordType.CNAME,
                                    description=f"Dangling CNAME pointing to non-existent {signature['service']} resource",
                                    evidence=f"CNAME: {cname}, No A record found",
                                    remediation="Remove the CNAME record or claim the resource",
                                    confidence=0.85,
                                    cwe_id="CWE-284",
                                )
                                return vuln
                
                return None
        
        tasks = [check_takeover(sub) for sub in subdomains_to_check]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, DNSVulnerability):
                vulnerabilities.append(result)
                await self._add_vulnerability(result)
        
        return vulnerabilities
    
    # =========================================================================
    # DNSSEC TESTING
    # =========================================================================
    
    async def test_dnssec(self, domain: str) -> List[DNSVulnerability]:
        """
        Test DNSSEC configuration
        
        Args:
            domain: Target domain
        """
        vulnerabilities = []
        
        if not DNS_AVAILABLE:
            return vulnerabilities
        
        logger.info(f"Testing DNSSEC for {domain}")
        
        # Check for DNSKEY records
        dnskey_records = await self._resolve(domain, 'DNSKEY')
        ds_records = await self._resolve(domain, 'DS')
        
        if not dnskey_records and not ds_records:
            vuln = DNSVulnerability(
                vuln_type=DNSVulnType.DNSSEC_DISABLED,
                severity=SeverityLevel.MEDIUM,
                domain=domain,
                description="DNSSEC is not enabled for this domain",
                evidence="No DNSKEY or DS records found",
                remediation="Enable DNSSEC to protect against DNS spoofing",
                confidence=0.95,
                cwe_id="CWE-350",
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        else:
            # DNSSEC is enabled, verify configuration
            if dnskey_records and not ds_records:
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.DNSSEC_MISCONFIGURED,
                    severity=SeverityLevel.MEDIUM,
                    domain=domain,
                    description="DNSSEC partially configured - DS record missing at parent",
                    evidence="DNSKEY present but no DS record found",
                    remediation="Add DS record to parent zone",
                    confidence=0.8,
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
            
            # Check for RRSIG (signatures)
            try:
                rrsig_records = await self._resolve(domain, 'RRSIG')
                if not rrsig_records:
                    vuln = DNSVulnerability(
                        vuln_type=DNSVulnType.DNSSEC_MISCONFIGURED,
                        severity=SeverityLevel.MEDIUM,
                        domain=domain,
                        description="DNSSEC configured but RRSIG records missing",
                        evidence="No RRSIG records found",
                        remediation="Ensure zone is properly signed",
                        confidence=0.7,
                    )
                    vulnerabilities.append(vuln)
            except Exception:
                pass
        
        return vulnerabilities
    
    # =========================================================================
    # EMAIL SECURITY (SPF/DKIM/DMARC)
    # =========================================================================
    
    async def test_email_security(self, domain: str) -> List[DNSVulnerability]:
        """
        Test email security configuration (SPF, DKIM, DMARC)
        
        Args:
            domain: Target domain
        """
        vulnerabilities = []
        
        logger.info(f"Testing email security for {domain}")
        
        # Check SPF
        txt_records = await self._resolve(domain, 'TXT')
        spf_records = [r for r in txt_records if 'v=spf1' in r.lower()]
        
        if not spf_records:
            vuln = DNSVulnerability(
                vuln_type=DNSVulnType.SPF_MISSING,
                severity=SeverityLevel.MEDIUM,
                domain=domain,
                record_type=RecordType.TXT,
                description="No SPF record found - email spoofing possible",
                remediation="Add SPF record to prevent email spoofing",
                confidence=0.95,
                cwe_id="CWE-290",
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        else:
            # Check for permissive SPF
            for spf in spf_records:
                if '+all' in spf.lower():
                    vuln = DNSVulnerability(
                        vuln_type=DNSVulnType.SPF_PERMISSIVE,
                        severity=SeverityLevel.HIGH,
                        domain=domain,
                        record_type=RecordType.TXT,
                        description="SPF record allows all senders (+all)",
                        evidence=f"SPF: {spf[:100]}",
                        remediation="Change +all to -all or ~all",
                        confidence=0.95,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
                elif '?all' in spf.lower():
                    vuln = DNSVulnerability(
                        vuln_type=DNSVulnType.SPF_PERMISSIVE,
                        severity=SeverityLevel.MEDIUM,
                        domain=domain,
                        record_type=RecordType.TXT,
                        description="SPF record uses neutral qualifier (?all)",
                        evidence=f"SPF: {spf[:100]}",
                        remediation="Change ?all to -all",
                        confidence=0.9,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        # Check DMARC
        dmarc_records = await self._resolve(f"_dmarc.{domain}", 'TXT')
        dmarc_found = [r for r in dmarc_records if 'v=dmarc1' in r.lower()]
        
        if not dmarc_found:
            vuln = DNSVulnerability(
                vuln_type=DNSVulnType.DMARC_MISSING,
                severity=SeverityLevel.MEDIUM,
                domain=domain,
                record_type=RecordType.TXT,
                description="No DMARC record found - no email authentication policy",
                remediation="Add DMARC record with reject/quarantine policy",
                confidence=0.95,
                cwe_id="CWE-290",
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        else:
            # Check for permissive DMARC
            for dmarc in dmarc_found:
                if 'p=none' in dmarc.lower():
                    vuln = DNSVulnerability(
                        vuln_type=DNSVulnType.DMARC_PERMISSIVE,
                        severity=SeverityLevel.LOW,
                        domain=domain,
                        record_type=RecordType.TXT,
                        description="DMARC policy is set to 'none' - no enforcement",
                        evidence=f"DMARC: {dmarc[:100]}",
                        remediation="Change p=none to p=quarantine or p=reject",
                        confidence=0.95,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        # Check for DKIM (common selectors)
        dkim_selectors = ['default', 'google', 'selector1', 'selector2', 'k1', 'k2', 'mail', 'dkim']
        dkim_found = False
        
        for selector in dkim_selectors:
            dkim_domain = f"{selector}._domainkey.{domain}"
            dkim_records = await self._resolve(dkim_domain, 'TXT')
            if dkim_records:
                dkim_found = True
                break
        
        if not dkim_found:
            vuln = DNSVulnerability(
                vuln_type=DNSVulnType.DKIM_MISSING,
                severity=SeverityLevel.LOW,
                domain=domain,
                record_type=RecordType.TXT,
                description="No DKIM records found (checked common selectors)",
                remediation="Configure DKIM for email authentication",
                confidence=0.7,  # Lower confidence as we may have missed the selector
            )
            vulnerabilities.append(vuln)
            await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # DANGLING NS DETECTION
    # =========================================================================
    
    async def check_dangling_ns(self, domain: str) -> List[DNSVulnerability]:
        """
        Check for dangling NS records (domain takeover risk)
        
        Args:
            domain: Target domain
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        logger.info(f"Checking NS records for {domain}")
        
        ns_records = await self._resolve(domain, 'NS')
        
        for ns in ns_records:
            ns_host = ns.rstrip('.')
            
            # Check if NS resolves
            ns_ips = await self._resolve(ns_host, 'A')
            
            if not ns_ips:
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.DANGLING_NS,
                    severity=SeverityLevel.CRITICAL,
                    domain=domain,
                    record_type=RecordType.NS,
                    description=f"Dangling NS record - nameserver {ns_host} has no A record",
                    evidence=f"NS: {ns_host} does not resolve",
                    remediation="Remove or update the NS record",
                    confidence=0.95,
                    cwe_id="CWE-284",
                    metadata={'nameserver': ns_host},
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
            else:
                # Check if we can query the NS
                try:
                    test_resolver = dns.resolver.Resolver()
                    test_resolver.nameservers = ns_ips[:1]
                    test_resolver.timeout = 3.0
                    test_resolver.lifetime = 5.0
                    test_resolver.resolve(domain, 'A')
                except Exception as e:
                    # NS exists but doesn't serve the zone
                    vuln = DNSVulnerability(
                        vuln_type=DNSVulnType.DANGLING_NS,
                        severity=SeverityLevel.HIGH,
                        domain=domain,
                        record_type=RecordType.NS,
                        description=f"NS {ns_host} exists but doesn't serve zone",
                        evidence=f"Query error: {str(e)[:100]}",
                        remediation="Verify NS configuration or remove record",
                        confidence=0.8,
                    )
                    vulnerabilities.append(vuln)
                    await self._add_vulnerability(vuln)
        
        # Check for single NS provider (availability risk)
        if ns_records:
            ns_domains = set()
            for ns in ns_records:
                parts = ns.rstrip('.').split('.')
                if len(parts) >= 2:
                    ns_domains.add('.'.join(parts[-2:]))
            
            if len(ns_domains) == 1:
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.NS_SINGLE_PROVIDER,
                    severity=SeverityLevel.LOW,
                    domain=domain,
                    record_type=RecordType.NS,
                    description="All nameservers from single provider - availability risk",
                    evidence=f"Provider: {list(ns_domains)[0]}",
                    remediation="Consider using secondary DNS from different provider",
                    confidence=0.9,
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
        
        return vulnerabilities
    
    # =========================================================================
    # OPEN RESOLVER TESTING
    # =========================================================================
    
    async def test_open_resolver(self, dns_server: str) -> List[DNSVulnerability]:
        """
        Test if DNS server is an open resolver
        
        Args:
            dns_server: DNS server IP to test
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        if not DNS_AVAILABLE:
            return vulnerabilities
        
        logger.info(f"Testing open resolver: {dns_server}")
        
        try:
            # Try to resolve an external domain
            test_resolver = dns.resolver.Resolver()
            test_resolver.nameservers = [dns_server]
            test_resolver.timeout = 5.0
            test_resolver.lifetime = 10.0
            
            # Query a well-known domain
            answers = test_resolver.resolve('google.com', 'A')
            
            if answers:
                # Server responded - it's an open resolver
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.OPEN_RESOLVER,
                    severity=SeverityLevel.MEDIUM,
                    domain=dns_server,
                    description="DNS server is an open resolver - can be abused for amplification",
                    evidence=f"Successfully resolved external domain",
                    remediation="Restrict DNS queries to authorized clients",
                    confidence=0.95,
                    cwe_id="CWE-406",
                )
                vulnerabilities.append(vuln)
                await self._add_vulnerability(vuln)
                
                # Test for amplification potential
                await self._test_dns_amplification(dns_server)
        
        except Exception as e:
            logger.debug(f"Server {dns_server} is not an open resolver: {e}")
        
        return vulnerabilities
    
    async def _test_dns_amplification(self, dns_server: str):
        """Test DNS amplification potential"""
        if not DNS_AVAILABLE:
            return
        
        try:
            # Send ANY query for amplification test
            test_resolver = dns.resolver.Resolver()
            test_resolver.nameservers = [dns_server]
            
            # Query for ANY records (large response)
            query = dns.message.make_query('google.com', dns.rdatatype.ANY)
            response = dns.query.udp(query, dns_server, timeout=5)
            
            # Check amplification factor
            query_size = len(query.to_wire())
            response_size = len(response.to_wire())
            
            if response_size > query_size * 5:
                vuln = DNSVulnerability(
                    vuln_type=DNSVulnType.DNS_AMPLIFICATION,
                    severity=SeverityLevel.HIGH,
                    domain=dns_server,
                    description=f"DNS amplification possible - {response_size/query_size:.1f}x amplification",
                    evidence=f"Query: {query_size} bytes, Response: {response_size} bytes",
                    remediation="Disable ANY queries, implement response rate limiting",
                    confidence=0.9,
                    cwe_id="CWE-406",
                )
                await self._add_vulnerability(vuln)
        
        except Exception:
            pass
    
    # =========================================================================
    # DNS VERSION DETECTION
    # =========================================================================
    
    async def detect_dns_version(self, dns_server: str) -> Optional[str]:
        """
        Detect DNS server version (information disclosure)
        
        Args:
            dns_server: DNS server IP
        """
        if not DNS_AVAILABLE:
            return None
        
        version_queries = [
            ('version.bind', 'CH', 'TXT'),
            ('version.server', 'CH', 'TXT'),
            ('hostname.bind', 'CH', 'TXT'),
        ]
        
        for qname, qclass, qtype in version_queries:
            try:
                query = dns.message.make_query(
                    qname,
                    dns.rdatatype.from_text(qtype),
                    dns.rdataclass.from_text(qclass)
                )
                response = dns.query.udp(query, dns_server, timeout=3)
                
                for rrset in response.answer:
                    for rdata in rrset:
                        version = str(rdata).strip('"')
                        
                        vuln = DNSVulnerability(
                            vuln_type=DNSVulnType.EXPOSED_VERSION,
                            severity=SeverityLevel.LOW,
                            domain=dns_server,
                            description="DNS server version exposed",
                            evidence=f"Version: {version}",
                            remediation="Hide DNS version information",
                            confidence=0.95,
                            cwe_id="CWE-200",
                        )
                        await self._add_vulnerability(vuln)
                        return version
            
            except Exception:
                continue
        
        return None
    
    # =========================================================================
    # WILDCARD DNS DETECTION
    # =========================================================================
    
    async def detect_wildcard_dns(self, domain: str) -> bool:
        """
        Detect wildcard DNS configuration
        
        Args:
            domain: Target domain
        """
        # Generate random subdomain
        random_sub = f"rf-arsenal-test-{secrets.token_hex(8)}.{domain}"
        
        ips = await self._resolve(random_sub, 'A')
        
        if ips:
            vuln = DNSVulnerability(
                vuln_type=DNSVulnType.WILDCARD_DNS,
                severity=SeverityLevel.INFO,
                domain=domain,
                record_type=RecordType.A,
                description="Wildcard DNS configured - all subdomains resolve",
                evidence=f"Random subdomain {random_sub} resolved to {ips[0]}",
                remediation="Consider if wildcard DNS is necessary",
                confidence=0.95,
            )
            await self._add_vulnerability(vuln)
            return True
        
        return False
    
    # =========================================================================
    # MAIN SCAN METHOD
    # =========================================================================
    
    async def scan(self, domain: str, config: Optional[DNSSecurityConfig] = None) -> List[DNSVulnerability]:
        """
        Run comprehensive DNS security scan
        
        Args:
            domain: Target domain
            config: Optional configuration
        """
        if config:
            self.config = config
        elif not self.config:
            self.config = DNSSecurityConfig(target_domain=domain)
        
        if not self._authorized:
            logger.error("Scan not authorized. Call authorize() first.")
            return []
        
        self._running = True
        self.vulnerabilities = []
        
        logger.info(f"Starting DNS security scan for {domain}")
        
        try:
            tasks = []
            
            # Zone transfer testing
            if self.config.test_zone_transfer:
                await self.test_zone_transfer(domain)
            
            # DNSSEC testing
            if self.config.test_dnssec:
                await self.test_dnssec(domain)
            
            # Email security
            if self.config.test_email_security:
                await self.test_email_security(domain)
            
            # Dangling NS check
            await self.check_dangling_ns(domain)
            
            # Wildcard detection
            await self.detect_wildcard_dns(domain)
            
            # Subdomain enumeration
            if self.config.enumerate_subdomains:
                await self.enumerate_subdomains(domain)
            
            # Subdomain takeover testing
            if self.config.test_subdomain_takeover and self.subdomains:
                await self.check_subdomain_takeover()
        
        except Exception as e:
            logger.error(f"Scan error: {e}")
        finally:
            self._running = False
        
        logger.info(f"Scan complete. Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities
    
    def get_stats(self) -> Dict[str, Any]:
        """Get scan statistics"""
        return {
            'dns_queries': self.stats['dns_queries'],
            'subdomains_found': len(self.subdomains),
            'records_found': len(self.dns_records),
            'vulnerabilities': len(self.vulnerabilities),
        }
    
    def get_report(self, format: str = "json") -> str:
        """Generate security report"""
        if format == "json":
            return json.dumps({
                'scan_time': datetime.now().isoformat(),
                'target': self.config.target_domain if self.config else None,
                'statistics': self.get_stats(),
                'subdomains': [
                    {'name': s.name, 'ips': s.ip_addresses, 'cname': s.cname, 'takeover': s.takeover_possible}
                    for s in self.subdomains[:100]
                ],
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }, indent=2)
        
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - DNS SECURITY SCAN REPORT",
                "=" * 70,
                f"Target: {self.config.target_domain if self.config else 'N/A'}",
                f"Scan Time: {datetime.now().isoformat()}",
                "",
                "STATISTICS:",
                f"  DNS Queries: {self.stats['dns_queries']}",
                f"  Subdomains Found: {len(self.subdomains)}",
                f"  Vulnerabilities: {len(self.vulnerabilities)}",
                "",
                "SUBDOMAINS:",
            ]
            
            for sub in self.subdomains[:20]:
                status = "[TAKEOVER]" if sub.takeover_possible else "[OK]"
                lines.append(f"  {status} {sub.name}")
            
            if len(self.subdomains) > 20:
                lines.append(f"  ... and {len(self.subdomains) - 20} more")
            
            lines.append("")
            lines.append("VULNERABILITIES:")
            lines.append("-" * 50)
            
            for vuln in sorted(self.vulnerabilities, key=lambda v: list(SeverityLevel).index(v.severity)):
                lines.append(f"\n[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  Domain: {vuln.domain}")
                lines.append(f"  Description: {vuln.description}")
                if vuln.remediation:
                    lines.append(f"  Remediation: {vuln.remediation}")
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear all results from RAM"""
        self.vulnerabilities = []
        self.subdomains = []
        self.dns_records = []
        self.stats = defaultdict(int)
        logger.info("Results cleared from RAM")


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def create_dns_scanner(
    domain: str,
    enumerate_subdomains: bool = True,
) -> DNSSecurityScanner:
    """Factory function to create DNS scanner"""
    config = DNSSecurityConfig(
        target_domain=domain,
        enumerate_subdomains=enumerate_subdomains,
    )
    return DNSSecurityScanner(config)


async def quick_dns_scan(domain: str) -> List[DNSVulnerability]:
    """Quick DNS security scan"""
    scanner = create_dns_scanner(domain)
    scanner.authorize("I_AUTHORIZE_DNS_TESTING")
    return await scanner.scan(domain)


# =============================================================================
# MODULE INFO
# =============================================================================

__all__ = [
    # Main classes
    'DNSSecurityScanner',
    'DNSSecurityConfig',
    'DNSVulnerability',
    'DNSRecord',
    'Subdomain',
    # Enums
    'DNSVulnType',
    'SeverityLevel',
    'RecordType',
    # Convenience functions
    'create_dns_scanner',
    'quick_dns_scan',
]

__version__ = '1.0.0'
__author__ = 'RF Arsenal Security Team'


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def main():
        print("RF Arsenal OS - DNS Security Scanner")
        print("=" * 50)
        print("\nCapabilities:")
        print("  - DNS zone transfer testing")
        print("  - Subdomain enumeration")
        print("  - Subdomain takeover detection")
        print("  - DNSSEC validation")
        print("  - Email security (SPF/DKIM/DMARC)")
        print("  - Dangling NS detection")
        print("  - Open resolver testing")
        print("\nUsage:")
        print("  scanner = create_dns_scanner('example.com')")
        print("  scanner.authorize('I_AUTHORIZE_DNS_TESTING')")
        print("  await scanner.scan('example.com')")
    
    asyncio.run(main())
