#!/usr/bin/env python3
"""
RF Arsenal OS - Proxy Chain Manager
====================================

Stealth proxy chain management for anonymous operations.
Supports SOCKS5, HTTP proxies, Tor circuits, and traffic obfuscation.

STEALTH FEATURES:
- Multi-hop proxy chains
- Automatic Tor circuit management
- Proxy rotation
- Traffic fingerprint obfuscation
- Connection health monitoring
- Fail-safe mechanisms

Author: RF Arsenal Security Team
License: Authorized Use Only
"""

import asyncio
import aiohttp
import hashlib
import json
import logging
import os
import random
import re
import socket
import ssl
import struct
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple
from collections import defaultdict

logger = logging.getLogger(__name__)


class ProxyType(Enum):
    """Proxy types"""
    HTTP = "http"
    HTTPS = "https"
    SOCKS4 = "socks4"
    SOCKS5 = "socks5"
    TOR = "tor"
    I2P = "i2p"


class ProxyStatus(Enum):
    """Proxy status"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    SLOW = "slow"
    BLOCKED = "blocked"
    UNKNOWN = "unknown"


@dataclass
class Proxy:
    """Individual proxy configuration"""
    host: str
    port: int
    proxy_type: ProxyType
    username: Optional[str] = None
    password: Optional[str] = None
    country: Optional[str] = None
    provider: Optional[str] = None
    status: ProxyStatus = ProxyStatus.UNKNOWN
    response_time: float = 0.0
    last_check: Optional[datetime] = None
    success_count: int = 0
    failure_count: int = 0
    
    @property
    def url(self) -> str:
        """Get proxy URL"""
        auth = ""
        if self.username and self.password:
            auth = f"{self.username}:{self.password}@"
        
        if self.proxy_type in [ProxyType.SOCKS4, ProxyType.SOCKS5]:
            scheme = self.proxy_type.value
        else:
            scheme = self.proxy_type.value
        
        return f"{scheme}://{auth}{self.host}:{self.port}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'host': self.host,
            'port': self.port,
            'type': self.proxy_type.value,
            'country': self.country,
            'status': self.status.value,
            'response_time': self.response_time,
            'success_rate': self.success_count / max(1, self.success_count + self.failure_count),
        }


@dataclass
class ProxyChain:
    """Chain of proxies for multi-hop routing"""
    proxies: List[Proxy] = field(default_factory=list)
    name: Optional[str] = None
    created: datetime = field(default_factory=datetime.now)
    
    def add_proxy(self, proxy: Proxy):
        """Add proxy to chain"""
        self.proxies.append(proxy)
    
    @property
    def length(self) -> int:
        """Number of hops"""
        return len(self.proxies)
    
    @property
    def total_latency(self) -> float:
        """Estimated total latency"""
        return sum(p.response_time for p in self.proxies)


@dataclass
class ProxyConfig:
    """Proxy manager configuration"""
    # Tor settings
    tor_control_port: int = 9051
    tor_socks_port: int = 9050
    tor_password: Optional[str] = None
    
    # Rotation settings
    rotation_interval: int = 300  # Seconds between rotations
    rotate_on_failure: bool = True
    max_failures: int = 3
    
    # Health check settings
    check_interval: int = 60
    check_timeout: float = 10.0
    check_url: str = "https://api.ipify.org?format=json"
    
    # Chain settings
    min_chain_length: int = 1
    max_chain_length: int = 3
    prefer_different_countries: bool = True
    
    # Stealth settings
    randomize_user_agent: bool = True
    add_random_delays: bool = True
    delay_min: float = 0.5
    delay_max: float = 2.0


class ProxyChainManager:
    """
    Proxy Chain Manager for Anonymous Operations
    
    Features:
    - Multi-hop proxy chains
    - Tor circuit management
    - Automatic rotation
    - Health monitoring
    - Traffic obfuscation
    
    STEALTH COMPLIANCE:
    - All proxy data in RAM only
    - No logging of connections
    - Automatic failover
    - Multiple anonymity layers
    """
    
    # Common User-Agents for rotation
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
    ]
    
    def __init__(self, config: Optional[ProxyConfig] = None):
        """Initialize proxy chain manager"""
        self.config = config or ProxyConfig()
        self.proxies: List[Proxy] = []
        self.chains: List[ProxyChain] = []
        self.active_chain: Optional[ProxyChain] = None
        self.tor_controller = None
        self._running = False
        self._rotation_task: Optional[asyncio.Task] = None
        self._health_task: Optional[asyncio.Task] = None
        self._lock = asyncio.Lock()
        self.stats = defaultdict(int)
        
        # Built-in Tor proxy
        self.tor_proxy = Proxy(
            host="127.0.0.1",
            port=self.config.tor_socks_port,
            proxy_type=ProxyType.TOR,
            country="Tor Exit",
        )
        
        logger.info("ProxyChainManager initialized - RAM-only operation")
    
    def add_proxy(self, proxy: Proxy):
        """Add proxy to pool"""
        self.proxies.append(proxy)
        logger.info(f"Added proxy: {proxy.host}:{proxy.port} ({proxy.proxy_type.value})")
    
    def add_proxies_from_list(self, proxy_list: List[Dict]):
        """
        Add multiple proxies from list
        
        Args:
            proxy_list: List of proxy dictionaries with keys:
                       host, port, type, username, password, country
        """
        for p in proxy_list:
            proxy = Proxy(
                host=p['host'],
                port=p['port'],
                proxy_type=ProxyType(p.get('type', 'socks5')),
                username=p.get('username'),
                password=p.get('password'),
                country=p.get('country'),
            )
            self.add_proxy(proxy)
    
    async def check_proxy(self, proxy: Proxy) -> bool:
        """
        Check if proxy is working
        
        Args:
            proxy: Proxy to check
            
        Returns:
            True if proxy is working
        """
        start_time = time.time()
        
        try:
            connector = aiohttp.TCPConnector(ssl=False)
            timeout = aiohttp.ClientTimeout(total=self.config.check_timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
            ) as session:
                async with session.get(
                    self.config.check_url,
                    proxy=proxy.url,
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        proxy.response_time = time.time() - start_time
                        proxy.status = ProxyStatus.ACTIVE
                        proxy.success_count += 1
                        proxy.last_check = datetime.now()
                        
                        logger.debug(f"Proxy {proxy.host}:{proxy.port} OK ({proxy.response_time:.2f}s)")
                        return True
            
        except Exception as e:
            logger.debug(f"Proxy {proxy.host}:{proxy.port} failed: {e}")
        
        proxy.status = ProxyStatus.INACTIVE
        proxy.failure_count += 1
        proxy.last_check = datetime.now()
        return False
    
    async def check_all_proxies(self):
        """Check all proxies in pool"""
        tasks = [self.check_proxy(p) for p in self.proxies]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        active = len([p for p in self.proxies if p.status == ProxyStatus.ACTIVE])
        logger.info(f"Proxy check complete: {active}/{len(self.proxies)} active")
    
    def get_active_proxies(self) -> List[Proxy]:
        """Get list of active proxies"""
        return [p for p in self.proxies if p.status == ProxyStatus.ACTIVE]
    
    def build_chain(self, length: Optional[int] = None, countries: Optional[List[str]] = None) -> ProxyChain:
        """
        Build a proxy chain
        
        Args:
            length: Number of hops (default: random within config limits)
            countries: Preferred countries for hops
            
        Returns:
            ProxyChain object
        """
        if length is None:
            length = random.randint(
                self.config.min_chain_length,
                self.config.max_chain_length
            )
        
        active_proxies = self.get_active_proxies()
        
        if not active_proxies:
            # Fall back to Tor
            logger.warning("No active proxies, using Tor")
            chain = ProxyChain(name="Tor Only")
            chain.add_proxy(self.tor_proxy)
            return chain
        
        # Select proxies for chain
        selected = []
        used_countries = set()
        
        for _ in range(length):
            candidates = active_proxies.copy()
            
            # Filter by country if configured
            if self.config.prefer_different_countries and used_countries:
                candidates = [p for p in candidates if p.country not in used_countries]
                if not candidates:
                    candidates = active_proxies.copy()
            
            if countries:
                country_candidates = [p for p in candidates if p.country in countries]
                if country_candidates:
                    candidates = country_candidates
            
            # Remove already selected
            candidates = [p for p in candidates if p not in selected]
            if not candidates:
                break
            
            # Select best proxy (lowest response time)
            proxy = min(candidates, key=lambda x: x.response_time)
            selected.append(proxy)
            if proxy.country:
                used_countries.add(proxy.country)
        
        chain = ProxyChain(proxies=selected)
        logger.info(f"Built chain with {chain.length} hops, latency: {chain.total_latency:.2f}s")
        
        return chain
    
    async def start_tor(self) -> bool:
        """
        Start Tor and connect to control port
        
        Returns:
            True if Tor is available
        """
        try:
            # Check if Tor is running
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            result = sock.connect_ex(('127.0.0.1', self.config.tor_socks_port))
            sock.close()
            
            if result != 0:
                # Try to start Tor
                try:
                    subprocess.run(['systemctl', 'start', 'tor'], 
                                 check=True, capture_output=True)
                    await asyncio.sleep(5)  # Wait for Tor to bootstrap
                except:
                    logger.error("Could not start Tor service")
                    return False
            
            # Test Tor connection
            if await self.check_proxy(self.tor_proxy):
                logger.info("Tor connection established")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Tor start error: {e}")
            return False
    
    async def new_tor_circuit(self) -> bool:
        """
        Request new Tor circuit
        
        Returns:
            True if new circuit established
        """
        try:
            # Connect to Tor control port
            reader, writer = await asyncio.open_connection(
                '127.0.0.1',
                self.config.tor_control_port
            )
            
            # Authenticate
            if self.config.tor_password:
                auth_cmd = f'AUTHENTICATE "{self.config.tor_password}"\r\n'
            else:
                auth_cmd = 'AUTHENTICATE\r\n'
            
            writer.write(auth_cmd.encode())
            await writer.drain()
            
            response = await reader.readline()
            if not response.startswith(b'250'):
                logger.error("Tor authentication failed")
                writer.close()
                return False
            
            # Request new circuit
            writer.write(b'SIGNAL NEWNYM\r\n')
            await writer.drain()
            
            response = await reader.readline()
            
            writer.close()
            await writer.wait_closed()
            
            if response.startswith(b'250'):
                logger.info("New Tor circuit established")
                await asyncio.sleep(1)  # Wait for circuit to build
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Tor circuit error: {e}")
            return False
    
    async def get_current_ip(self, proxy: Optional[Proxy] = None) -> Optional[str]:
        """
        Get current external IP through proxy
        
        Args:
            proxy: Proxy to use (None for direct connection)
            
        Returns:
            External IP address
        """
        try:
            timeout = aiohttp.ClientTimeout(total=10.0)
            
            async with aiohttp.ClientSession(timeout=timeout) as session:
                proxy_url = proxy.url if proxy else None
                
                async with session.get(
                    "https://api.ipify.org?format=json",
                    proxy=proxy_url,
                ) as response:
                    data = await response.json()
                    return data.get('ip')
                    
        except Exception as e:
            logger.debug(f"IP check failed: {e}")
            return None
    
    def set_active_chain(self, chain: ProxyChain):
        """Set the active proxy chain"""
        self.active_chain = chain
        logger.info(f"Active chain set: {chain.length} hops")
    
    def get_proxy_url(self) -> Optional[str]:
        """
        Get URL for current active proxy/chain
        
        For multi-hop chains, returns the first proxy URL.
        Full chain support requires proxychains or similar.
        
        Returns:
            Proxy URL or None
        """
        if self.active_chain and self.active_chain.proxies:
            # Return first proxy in chain
            # For full chain support, use get_proxychains_config()
            return self.active_chain.proxies[0].url
        
        return self.tor_proxy.url  # Default to Tor
    
    def get_proxychains_config(self) -> str:
        """
        Generate proxychains configuration
        
        Returns:
            Proxychains config file content
        """
        lines = [
            "# RF Arsenal OS - Proxychains Config",
            "# Generated: " + datetime.now().isoformat(),
            "",
            "strict_chain",
            "proxy_dns",
            "tcp_read_time_out 15000",
            "tcp_connect_time_out 8000",
            "",
            "[ProxyList]",
        ]
        
        if self.active_chain:
            for proxy in self.active_chain.proxies:
                auth = ""
                if proxy.username and proxy.password:
                    auth = f" {proxy.username} {proxy.password}"
                
                if proxy.proxy_type in [ProxyType.SOCKS4, ProxyType.SOCKS5]:
                    lines.append(f"{proxy.proxy_type.value} {proxy.host} {proxy.port}{auth}")
                elif proxy.proxy_type == ProxyType.HTTP:
                    lines.append(f"http {proxy.host} {proxy.port}{auth}")
        else:
            # Default to Tor
            lines.append(f"socks5 127.0.0.1 {self.config.tor_socks_port}")
        
        return "\n".join(lines)
    
    async def make_request(
        self,
        url: str,
        method: str = "GET",
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
        timeout: float = 30.0,
    ) -> Tuple[int, str, Dict]:
        """
        Make HTTP request through proxy chain
        
        Args:
            url: Target URL
            method: HTTP method
            data: Request data
            headers: Request headers
            timeout: Request timeout
            
        Returns:
            Tuple of (status_code, response_text, response_headers)
        """
        proxy_url = self.get_proxy_url()
        
        # Add stealth headers
        request_headers = {
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
        }
        
        if self.config.randomize_user_agent:
            request_headers["User-Agent"] = random.choice(self.USER_AGENTS)
        
        if headers:
            request_headers.update(headers)
        
        # Add random delay
        if self.config.add_random_delays:
            delay = random.uniform(self.config.delay_min, self.config.delay_max)
            await asyncio.sleep(delay)
        
        try:
            connector = aiohttp.TCPConnector(ssl=False)
            client_timeout = aiohttp.ClientTimeout(total=timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=client_timeout,
                headers=request_headers,
            ) as session:
                if method.upper() == "GET":
                    async with session.get(url, proxy=proxy_url) as response:
                        text = await response.text()
                        return response.status, text, dict(response.headers)
                        
                elif method.upper() == "POST":
                    async with session.post(url, data=data, proxy=proxy_url) as response:
                        text = await response.text()
                        return response.status, text, dict(response.headers)
                        
        except Exception as e:
            logger.error(f"Request failed: {e}")
            
            # Try rotation on failure
            if self.config.rotate_on_failure:
                await self.rotate_proxy()
                
            raise
    
    async def rotate_proxy(self):
        """Rotate to next proxy or new Tor circuit"""
        async with self._lock:
            if self.active_chain and self.active_chain.proxies:
                # Move failed proxy to end
                if len(self.active_chain.proxies) > 1:
                    failed = self.active_chain.proxies.pop(0)
                    failed.failure_count += 1
                    self.active_chain.proxies.append(failed)
                    logger.info("Rotated to next proxy in chain")
                else:
                    # Rebuild chain
                    self.active_chain = self.build_chain()
            else:
                # Request new Tor circuit
                await self.new_tor_circuit()
            
            self.stats['rotations'] += 1
    
    async def start_rotation_loop(self):
        """Start automatic rotation loop"""
        self._running = True
        
        while self._running:
            await asyncio.sleep(self.config.rotation_interval)
            
            if self._running:
                await self.rotate_proxy()
    
    async def start_health_check_loop(self):
        """Start health check loop"""
        while self._running:
            await asyncio.sleep(self.config.check_interval)
            
            if self._running:
                await self.check_all_proxies()
    
    async def start(self):
        """Start proxy manager with all background tasks"""
        # Start Tor
        await self.start_tor()
        
        # Check all proxies
        await self.check_all_proxies()
        
        # Build initial chain
        if self.get_active_proxies():
            self.active_chain = self.build_chain()
        
        # Start background tasks
        self._running = True
        self._rotation_task = asyncio.create_task(self.start_rotation_loop())
        self._health_task = asyncio.create_task(self.start_health_check_loop())
        
        logger.info("ProxyChainManager started")
    
    async def stop(self):
        """Stop proxy manager"""
        self._running = False
        
        if self._rotation_task:
            self._rotation_task.cancel()
            try:
                await self._rotation_task
            except asyncio.CancelledError:
                pass
        
        if self._health_task:
            self._health_task.cancel()
            try:
                await self._health_task
            except asyncio.CancelledError:
                pass
        
        logger.info("ProxyChainManager stopped")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get manager statistics"""
        return {
            'total_proxies': len(self.proxies),
            'active_proxies': len(self.get_active_proxies()),
            'current_chain_length': self.active_chain.length if self.active_chain else 0,
            'rotations': self.stats['rotations'],
            'tor_available': self.tor_proxy.status == ProxyStatus.ACTIVE,
        }
    
    def get_status(self) -> Dict[str, Any]:
        """Get detailed status"""
        return {
            'running': self._running,
            'stats': self.get_stats(),
            'active_chain': {
                'length': self.active_chain.length if self.active_chain else 0,
                'proxies': [p.to_dict() for p in self.active_chain.proxies] if self.active_chain else [],
            },
            'proxy_pool': [p.to_dict() for p in self.proxies],
        }
    
    def clear(self):
        """Clear all proxy data from RAM"""
        self.proxies = []
        self.chains = []
        self.active_chain = None
        self.stats = defaultdict(int)
        logger.info("Proxy data cleared from RAM")


# Quick setup functions
async def setup_tor_proxy() -> ProxyChainManager:
    """
    Quick setup with Tor only
    
    Returns:
        Configured ProxyChainManager
    """
    manager = ProxyChainManager()
    await manager.start_tor()
    return manager


async def setup_proxy_chain(proxies: List[Dict]) -> ProxyChainManager:
    """
    Quick setup with custom proxies
    
    Args:
        proxies: List of proxy dictionaries
        
    Returns:
        Configured ProxyChainManager
    """
    manager = ProxyChainManager()
    manager.add_proxies_from_list(proxies)
    await manager.check_all_proxies()
    manager.active_chain = manager.build_chain()
    return manager


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def main():
        manager = ProxyChainManager()
        
        # Start with Tor
        if await manager.start_tor():
            print(f"Tor proxy URL: {manager.tor_proxy.url}")
            
            # Get IP through Tor
            ip = await manager.get_current_ip(manager.tor_proxy)
            print(f"Current IP through Tor: {ip}")
            
            # Request new circuit
            await manager.new_tor_circuit()
            
            # Check new IP
            ip = await manager.get_current_ip(manager.tor_proxy)
            print(f"New IP after circuit change: {ip}")
    
    asyncio.run(main())
