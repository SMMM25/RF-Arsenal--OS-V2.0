#!/usr/bin/env python3
"""
RF Arsenal OS - WebSocket Security Testing Module
==================================================

Professional WebSocket security testing with stealth-first design.
Comprehensive testing for real-time protocol vulnerabilities.

CAPABILITIES:
- WebSocket protocol fuzzing
- CSWSH (Cross-Site WebSocket Hijacking) detection
- Message injection and replay
- Origin validation testing
- Authentication bypass testing
- Rate limiting assessment

README COMPLIANCE:
- Stealth-First: Controlled message rates
- RAM-Only: All findings stored in memory only
- No Telemetry: Zero external data transmission
- Offline-First: Protocol analysis works offline

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import base64
import hashlib
import json
import logging
import os
import random
import secrets
import struct
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

try:
    import websockets
    WEBSOCKETS_AVAILABLE = True
except ImportError:
    WEBSOCKETS_AVAILABLE = False

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

logger = logging.getLogger(__name__)


class WSVulnType(Enum):
    """WebSocket vulnerability types"""
    CSWSH = "cross_site_websocket_hijacking"
    ORIGIN_BYPASS = "origin_validation_bypass"
    AUTH_BYPASS = "authentication_bypass"
    MESSAGE_INJECTION = "message_injection"
    MESSAGE_TAMPERING = "message_tampering"
    NO_ENCRYPTION = "unencrypted_websocket"
    RATE_LIMIT_MISSING = "rate_limiting_missing"
    XSS_VIA_WS = "xss_via_websocket"
    SQLI_VIA_WS = "sql_injection_via_websocket"
    IDOR_VIA_WS = "idor_via_websocket"
    SENSITIVE_DATA_LEAK = "sensitive_data_leak"
    INSECURE_DESERIALIZATION = "insecure_deserialization"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


@dataclass
class WSVulnerability:
    """Detected WebSocket vulnerability"""
    vuln_type: WSVulnType
    severity: SeverityLevel
    endpoint: str
    description: str = ""
    evidence: Optional[str] = None
    payload: Optional[str] = None
    remediation: str = ""
    confidence: float = 0.0
    cwe_id: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'endpoint': self.endpoint,
            'description': self.description,
            'evidence': self.evidence[:500] if self.evidence else None,
            'payload': self.payload,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class WSMessage:
    """WebSocket message"""
    direction: str  # 'sent' or 'received'
    data: str
    timestamp: datetime = field(default_factory=datetime.now)
    is_binary: bool = False


class WebSocketSecurityScanner:
    """
    WebSocket Security Scanner
    
    Tests:
    - Cross-Site WebSocket Hijacking
    - Origin validation
    - Authentication bypass
    - Message injection
    - Fuzzing
    
    README COMPLIANCE:
    - Stealth-First: Controlled message rates
    - RAM-Only: No persistent storage
    - No Telemetry: Zero reporting
    """
    
    # Fuzzing payloads
    FUZZ_PAYLOADS = [
        # XSS
        '<script>alert(1)</script>',
        '"><script>alert(1)</script>',
        "'-alert(1)-'",
        # SQL Injection
        "' OR '1'='1",
        "'; DROP TABLE users;--",
        "1' AND SLEEP(5)--",
        # Command Injection
        "; ls -la",
        "| cat /etc/passwd",
        # JSON injection
        '{"__proto__": {"admin": true}}',
        '{"constructor": {"prototype": {"admin": true}}}',
        # Large payload
        'A' * 10000,
        # Null byte
        'test\x00admin',
        # Unicode
        'test\u0000admin',
    ]
    
    # Malicious origins for CSWSH testing
    EVIL_ORIGINS = [
        "https://evil.com",
        "https://attacker.com",
        "null",
        "file://",
    ]
    
    def __init__(self):
        """Initialize scanner"""
        self.vulnerabilities: List[WSVulnerability] = []
        self.messages: List[WSMessage] = []
        self.stats = defaultdict(int)
        self._authorized = False
        
        logger.info("WebSocketSecurityScanner initialized")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_WEBSOCKET_TESTING") -> bool:
        """Authorize testing"""
        if confirmation == "I_AUTHORIZE_WEBSOCKET_TESTING":
            self._authorized = True
            return True
        return False
    
    async def test_cswsh(
        self,
        ws_url: str,
        legitimate_origin: str,
    ) -> List[WSVulnerability]:
        """
        Test for Cross-Site WebSocket Hijacking
        
        Args:
            ws_url: WebSocket URL
            legitimate_origin: Expected origin
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        if not AIOHTTP_AVAILABLE:
            logger.warning("aiohttp not available")
            return vulnerabilities
        
        for evil_origin in self.EVIL_ORIGINS:
            try:
                # Try connecting with evil origin
                async with aiohttp.ClientSession() as session:
                    headers = {'Origin': evil_origin}
                    
                    async with session.ws_connect(
                        ws_url,
                        headers=headers,
                        ssl=False,
                    ) as ws:
                        # Connection succeeded with evil origin
                        vuln = WSVulnerability(
                            vuln_type=WSVulnType.CSWSH,
                            severity=SeverityLevel.HIGH,
                            endpoint=ws_url,
                            description=f"WebSocket accepts connections from evil origin: {evil_origin}",
                            evidence=f"Connected successfully with Origin: {evil_origin}",
                            remediation="Validate Origin header, implement CSRF tokens",
                            confidence=0.95,
                            cwe_id="CWE-346",
                        )
                        vulnerabilities.append(vuln)
                        self.vulnerabilities.append(vuln)
                        
                        await ws.close()
                        break
            
            except Exception as e:
                # Connection rejected - good
                logger.debug(f"Connection rejected for {evil_origin}: {e}")
                continue
        
        return vulnerabilities
    
    async def test_authentication(
        self,
        ws_url: str,
        auth_token: Optional[str] = None,
    ) -> List[WSVulnerability]:
        """
        Test WebSocket authentication
        
        Args:
            ws_url: WebSocket URL
            auth_token: Valid authentication token
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        if not AIOHTTP_AVAILABLE:
            return vulnerabilities
        
        try:
            # Try connecting without authentication
            async with aiohttp.ClientSession() as session:
                async with session.ws_connect(ws_url, ssl=False) as ws:
                    # Send a test message
                    await ws.send_str('{"action": "ping"}')
                    
                    try:
                        response = await asyncio.wait_for(ws.receive(), timeout=5)
                        
                        if response.type == aiohttp.WSMsgType.TEXT:
                            # Got response without auth
                            vuln = WSVulnerability(
                                vuln_type=WSVulnType.AUTH_BYPASS,
                                severity=SeverityLevel.HIGH,
                                endpoint=ws_url,
                                description="WebSocket accessible without authentication",
                                evidence=f"Response: {response.data[:100]}",
                                remediation="Require authentication for WebSocket connections",
                                confidence=0.9,
                                cwe_id="CWE-287",
                            )
                            vulnerabilities.append(vuln)
                            self.vulnerabilities.append(vuln)
                    
                    except asyncio.TimeoutError:
                        pass
                    
                    await ws.close()
        
        except Exception as e:
            logger.debug(f"Auth test error: {e}")
        
        return vulnerabilities
    
    async def fuzz_websocket(
        self,
        ws_url: str,
        auth_headers: Optional[Dict] = None,
    ) -> List[WSVulnerability]:
        """
        Fuzz WebSocket endpoint
        
        Args:
            ws_url: WebSocket URL
            auth_headers: Authentication headers
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        if not AIOHTTP_AVAILABLE:
            return vulnerabilities
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.ws_connect(
                    ws_url,
                    headers=auth_headers,
                    ssl=False,
                ) as ws:
                    
                    for payload in self.FUZZ_PAYLOADS:
                        try:
                            # Send fuzz payload
                            await ws.send_str(payload)
                            self.stats['messages_sent'] += 1
                            
                            # Record message
                            self.messages.append(WSMessage(
                                direction='sent',
                                data=payload,
                            ))
                            
                            # Wait for response
                            try:
                                response = await asyncio.wait_for(ws.receive(), timeout=2)
                                
                                if response.type == aiohttp.WSMsgType.TEXT:
                                    resp_data = response.data
                                    
                                    self.messages.append(WSMessage(
                                        direction='received',
                                        data=resp_data,
                                    ))
                                    
                                    # Check for error signatures
                                    self._analyze_response(ws_url, payload, resp_data, vulnerabilities)
                            
                            except asyncio.TimeoutError:
                                continue
                        
                        except Exception:
                            continue
                    
                    await ws.close()
        
        except Exception as e:
            logger.debug(f"Fuzzing error: {e}")
        
        return vulnerabilities
    
    def _analyze_response(
        self,
        endpoint: str,
        payload: str,
        response: str,
        vulnerabilities: List[WSVulnerability],
    ):
        """Analyze WebSocket response for vulnerabilities"""
        response_lower = response.lower()
        
        # SQL error signatures
        sql_errors = ['sql', 'syntax', 'mysql', 'postgres', 'sqlite', 'oracle']
        if any(err in response_lower for err in sql_errors):
            vuln = WSVulnerability(
                vuln_type=WSVulnType.SQLI_VIA_WS,
                severity=SeverityLevel.CRITICAL,
                endpoint=endpoint,
                description="SQL injection via WebSocket",
                evidence=f"SQL error in response: {response[:200]}",
                payload=payload,
                remediation="Sanitize WebSocket message inputs",
                confidence=0.85,
                cwe_id="CWE-89",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        # XSS reflection
        if payload in response and '<script' in payload:
            vuln = WSVulnerability(
                vuln_type=WSVulnType.XSS_VIA_WS,
                severity=SeverityLevel.HIGH,
                endpoint=endpoint,
                description="XSS payload reflected via WebSocket",
                evidence=f"Payload reflected: {payload[:50]}",
                payload=payload,
                remediation="Encode WebSocket message output",
                confidence=0.8,
                cwe_id="CWE-79",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        # Sensitive data in response
        sensitive_patterns = ['password', 'token', 'secret', 'api_key', 'apikey']
        for pattern in sensitive_patterns:
            if pattern in response_lower:
                vuln = WSVulnerability(
                    vuln_type=WSVulnType.SENSITIVE_DATA_LEAK,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    description=f"Sensitive data ({pattern}) in WebSocket response",
                    remediation="Filter sensitive data from responses",
                    confidence=0.7,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
                break
    
    async def test_rate_limiting(
        self,
        ws_url: str,
        message_count: int = 100,
    ) -> List[WSVulnerability]:
        """Test WebSocket rate limiting"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        if not AIOHTTP_AVAILABLE:
            return vulnerabilities
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.ws_connect(ws_url, ssl=False) as ws:
                    
                    success_count = 0
                    start_time = time.time()
                    
                    for i in range(message_count):
                        try:
                            await ws.send_str(f'{{"action": "ping", "id": {i}}}')
                            success_count += 1
                        except Exception:
                            break
                    
                    elapsed = time.time() - start_time
                    rate = success_count / elapsed if elapsed > 0 else 0
                    
                    if success_count >= message_count * 0.9:
                        vuln = WSVulnerability(
                            vuln_type=WSVulnType.RATE_LIMIT_MISSING,
                            severity=SeverityLevel.MEDIUM,
                            endpoint=ws_url,
                            description=f"No rate limiting - sent {success_count} messages in {elapsed:.1f}s",
                            evidence=f"Rate: {rate:.1f} msg/sec",
                            remediation="Implement message rate limiting",
                            confidence=0.85,
                        )
                        vulnerabilities.append(vuln)
                        self.vulnerabilities.append(vuln)
                    
                    await ws.close()
        
        except Exception as e:
            logger.debug(f"Rate limit test error: {e}")
        
        return vulnerabilities
    
    def analyze_ws_protocol(self, url: str) -> List[WSVulnerability]:
        """Analyze WebSocket URL for security issues (offline)"""
        vulnerabilities = []
        
        # Check for unencrypted WebSocket
        if url.startswith('ws://') and not url.startswith('ws://localhost') and not url.startswith('ws://127.'):
            vuln = WSVulnerability(
                vuln_type=WSVulnType.NO_ENCRYPTION,
                severity=SeverityLevel.MEDIUM,
                endpoint=url,
                description="WebSocket connection is unencrypted (ws://)",
                remediation="Use wss:// for encrypted WebSocket connections",
                confidence=1.0,
                cwe_id="CWE-319",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def scan(
        self,
        ws_url: str,
        origin: Optional[str] = None,
        auth_headers: Optional[Dict] = None,
    ) -> List[WSVulnerability]:
        """
        Run comprehensive WebSocket security scan
        """
        if not self._authorized:
            logger.error("Scan not authorized")
            return []
        
        all_vulnerabilities = []
        
        logger.info(f"Starting WebSocket security scan: {ws_url}")
        
        # Protocol analysis (offline)
        vulns = self.analyze_ws_protocol(ws_url)
        all_vulnerabilities.extend(vulns)
        
        # CSWSH testing
        if origin:
            vulns = await self.test_cswsh(ws_url, origin)
            all_vulnerabilities.extend(vulns)
        
        # Authentication testing
        vulns = await self.test_authentication(ws_url)
        all_vulnerabilities.extend(vulns)
        
        # Fuzzing
        vulns = await self.fuzz_websocket(ws_url, auth_headers)
        all_vulnerabilities.extend(vulns)
        
        # Rate limiting
        vulns = await self.test_rate_limiting(ws_url)
        all_vulnerabilities.extend(vulns)
        
        logger.info(f"Scan complete. Found {len(all_vulnerabilities)} vulnerabilities")
        return all_vulnerabilities
    
    def get_report(self, format: str = "json") -> str:
        """Generate report"""
        if format == "json":
            return json.dumps({
                'scan_time': datetime.now().isoformat(),
                'messages_sent': self.stats['messages_sent'],
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }, indent=2)
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - WEBSOCKET SECURITY REPORT",
                "=" * 70,
                f"Messages Sent: {self.stats['messages_sent']}",
                f"Vulnerabilities: {len(self.vulnerabilities)}",
                "",
            ]
            
            for vuln in self.vulnerabilities:
                lines.append(f"[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  Endpoint: {vuln.endpoint}")
                lines.append(f"  {vuln.description}")
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear results from RAM"""
        self.vulnerabilities = []
        self.messages = []
        self.stats = defaultdict(int)


def create_websocket_scanner() -> WebSocketSecurityScanner:
    """Factory function"""
    return WebSocketSecurityScanner()


__all__ = [
    'WebSocketSecurityScanner',
    'WSVulnerability',
    'WSVulnType',
    'WSMessage',
    'SeverityLevel',
    'create_websocket_scanner',
]

__version__ = '1.0.0'
