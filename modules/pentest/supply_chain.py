#!/usr/bin/env python3
"""
RF Arsenal OS - Supply Chain Security Module
=============================================

Professional supply chain security testing with stealth-first design.
Comprehensive testing for dependency confusion, typosquatting, and CI/CD vulnerabilities.

CAPABILITIES:
- Dependency confusion attack detection
- Package typosquatting analysis
- CI/CD pipeline security assessment
- Container image security
- Source code dependency analysis
- Build artifact integrity verification

README COMPLIANCE:
- Stealth-First: Rate-limited queries, randomized timing
- RAM-Only: All findings stored in memory only
- No Telemetry: Zero external data transmission
- Offline-First: Local analysis capabilities

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import base64
import hashlib
import json
import logging
import os
import random
import re
import secrets
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

logger = logging.getLogger(__name__)


class SupplyChainVulnType(Enum):
    """Supply chain vulnerability types"""
    DEPENDENCY_CONFUSION = "dependency_confusion"
    TYPOSQUATTING = "typosquatting"
    MALICIOUS_PACKAGE = "malicious_package"
    OUTDATED_DEPENDENCY = "outdated_dependency"
    KNOWN_VULNERABLE = "known_vulnerable_dependency"
    CI_CD_LEAK = "ci_cd_secret_leak"
    CI_CD_INJECTION = "ci_cd_injection"
    BUILD_TAMPERING = "build_artifact_tampering"
    CONTAINER_VULN = "container_vulnerability"
    UNSIGNED_ARTIFACT = "unsigned_artifact"
    COMPROMISED_REGISTRY = "compromised_registry"
    DEPENDENCY_HIJACK = "dependency_hijacking"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


class PackageRegistry(Enum):
    """Package registries"""
    NPM = "npm"
    PYPI = "pypi"
    MAVEN = "maven"
    RUBYGEMS = "rubygems"
    NUGET = "nuget"
    DOCKER = "docker"
    GO = "go"


@dataclass
class SupplyChainVulnerability:
    """Detected supply chain vulnerability"""
    vuln_type: SupplyChainVulnType
    severity: SeverityLevel
    package: str
    registry: PackageRegistry
    description: str = ""
    evidence: Optional[str] = None
    remediation: str = ""
    confidence: float = 0.0
    cve_id: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'package': self.package,
            'registry': self.registry.value,
            'description': self.description,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'cve_id': self.cve_id,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class Package:
    """Package information"""
    name: str
    version: str
    registry: PackageRegistry
    is_private: bool = False
    maintainer: Optional[str] = None
    download_count: int = 0
    last_updated: Optional[datetime] = None


class SupplyChainScanner:
    """
    Supply Chain Security Scanner
    
    Tests:
    - Dependency confusion vulnerabilities
    - Package typosquatting
    - Outdated/vulnerable dependencies
    - CI/CD security
    
    README COMPLIANCE:
    - Stealth-First: Rate-limited requests
    - RAM-Only: No persistent storage
    - No Telemetry: Zero reporting
    """
    
    # Common typosquatting patterns
    TYPOSQUAT_PATTERNS = [
        lambda name: name.replace('-', ''),  # lodash -> lodash
        lambda name: name.replace('_', '-'),  # my_pkg -> my-pkg
        lambda name: name.replace('-', '_'),  # my-pkg -> my_pkg
        lambda name: name + 's',  # request -> requests
        lambda name: name[:-1] if name.endswith('s') else name,  # requests -> request
        lambda name: 'python-' + name,  # requests -> python-requests
        lambda name: name + '-python',  # requests -> requests-python
        lambda name: 'py' + name,  # requests -> pyrequests
        lambda name: name + '-js',  # lodash -> lodash-js
        lambda name: name + '-node',  # express -> express-node
    ]
    
    # Known malicious package indicators
    MALICIOUS_INDICATORS = [
        r'base64.*decode.*exec',
        r'eval\s*\(',
        r'subprocess\.call',
        r'os\.system',
        r'requests\.get.*http.*\.exe',
        r'urllib.*download',
        r'socket.*connect',
        r'crypto.*encrypt',
    ]
    
    def __init__(self):
        """Initialize scanner"""
        self.vulnerabilities: List[SupplyChainVulnerability] = []
        self.stats = defaultdict(int)
        self._authorized = False
        
        logger.info("SupplyChainScanner initialized")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_SUPPLY_CHAIN_TESTING") -> bool:
        """Authorize testing"""
        if confirmation == "I_AUTHORIZE_SUPPLY_CHAIN_TESTING":
            self._authorized = True
            return True
        return False
    
    async def _make_request(self, url: str) -> Tuple[Optional[int], Optional[str]]:
        """Make HTTP request"""
        if not AIOHTTP_AVAILABLE:
            return None, None
        
        try:
            timeout = aiohttp.ClientTimeout(total=10)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.get(url) as response:
                    text = await response.text()
                    return response.status, text
        except Exception:
            return None, None
    
    async def check_dependency_confusion(
        self,
        private_packages: List[str],
        registry: PackageRegistry = PackageRegistry.NPM,
    ) -> List[SupplyChainVulnerability]:
        """
        Check for dependency confusion vulnerabilities
        
        Tests if private package names exist on public registries
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        registry_urls = {
            PackageRegistry.NPM: "https://registry.npmjs.org/{}",
            PackageRegistry.PYPI: "https://pypi.org/pypi/{}/json",
        }
        
        url_template = registry_urls.get(registry)
        if not url_template:
            return vulnerabilities
        
        for package in private_packages:
            url = url_template.format(package)
            status, response = await self._make_request(url)
            
            if status == 200:
                # Public package exists with same name
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.DEPENDENCY_CONFUSION,
                    severity=SeverityLevel.HIGH,
                    package=package,
                    registry=registry,
                    description=f"Private package '{package}' name exists on public registry",
                    evidence=f"Public package found at {url}",
                    remediation="Use scoped packages (@org/package) or prefix with organization name",
                    confidence=0.9,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def check_typosquatting(
        self,
        packages: List[str],
        registry: PackageRegistry = PackageRegistry.NPM,
    ) -> List[SupplyChainVulnerability]:
        """
        Check for typosquatting packages
        """
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        registry_urls = {
            PackageRegistry.NPM: "https://registry.npmjs.org/{}",
            PackageRegistry.PYPI: "https://pypi.org/pypi/{}/json",
        }
        
        url_template = registry_urls.get(registry)
        if not url_template:
            return vulnerabilities
        
        for package in packages:
            for pattern_fn in self.TYPOSQUAT_PATTERNS:
                try:
                    typosquat_name = pattern_fn(package)
                    if typosquat_name == package:
                        continue
                    
                    url = url_template.format(typosquat_name)
                    status, _ = await self._make_request(url)
                    
                    if status == 200:
                        vuln = SupplyChainVulnerability(
                            vuln_type=SupplyChainVulnType.TYPOSQUATTING,
                            severity=SeverityLevel.MEDIUM,
                            package=typosquat_name,
                            registry=registry,
                            description=f"Potential typosquat of '{package}': '{typosquat_name}'",
                            evidence=f"Package exists at {url}",
                            remediation="Verify package name carefully before installation",
                            confidence=0.7,
                            metadata={'original': package, 'typosquat': typosquat_name},
                        )
                        vulnerabilities.append(vuln)
                        self.vulnerabilities.append(vuln)
                except Exception:
                    continue
        
        return vulnerabilities
    
    def analyze_package_json(self, content: str) -> List[SupplyChainVulnerability]:
        """Analyze package.json for vulnerabilities (offline)"""
        vulnerabilities = []
        
        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            return vulnerabilities
        
        dependencies = {}
        dependencies.update(data.get('dependencies', {}))
        dependencies.update(data.get('devDependencies', {}))
        
        for name, version in dependencies.items():
            # Check for wildcard versions
            if version == '*' or version == 'latest':
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.DEPENDENCY_HIJACK,
                    severity=SeverityLevel.HIGH,
                    package=name,
                    registry=PackageRegistry.NPM,
                    description=f"Dependency '{name}' uses unsafe version specifier: {version}",
                    remediation="Pin to specific version",
                    confidence=0.95,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
            
            # Check for git URLs (potential compromise)
            if 'git' in str(version):
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.DEPENDENCY_HIJACK,
                    severity=SeverityLevel.MEDIUM,
                    package=name,
                    registry=PackageRegistry.NPM,
                    description=f"Dependency '{name}' uses git URL: {version}",
                    remediation="Use published packages from registry",
                    confidence=0.8,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        # Check for suspicious scripts
        scripts = data.get('scripts', {})
        for script_name, script_cmd in scripts.items():
            for pattern in self.MALICIOUS_INDICATORS:
                if re.search(pattern, script_cmd, re.IGNORECASE):
                    vuln = SupplyChainVulnerability(
                        vuln_type=SupplyChainVulnType.MALICIOUS_PACKAGE,
                        severity=SeverityLevel.CRITICAL,
                        package=data.get('name', 'unknown'),
                        registry=PackageRegistry.NPM,
                        description=f"Suspicious pattern in script '{script_name}'",
                        evidence=f"Pattern matched: {pattern}",
                        remediation="Review script contents, consider removing package",
                        confidence=0.85,
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def analyze_requirements_txt(self, content: str) -> List[SupplyChainVulnerability]:
        """Analyze requirements.txt for vulnerabilities (offline)"""
        vulnerabilities = []
        
        for line in content.strip().split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Parse requirement
            match = re.match(r'^([a-zA-Z0-9_-]+)(.*)$', line)
            if not match:
                continue
            
            name = match.group(1)
            version_spec = match.group(2).strip()
            
            # Check for unpinned versions
            if not version_spec or version_spec.startswith('>=') or version_spec.startswith('>'):
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.DEPENDENCY_HIJACK,
                    severity=SeverityLevel.MEDIUM,
                    package=name,
                    registry=PackageRegistry.PYPI,
                    description=f"Dependency '{name}' not pinned to specific version",
                    evidence=f"Version spec: {version_spec or 'none'}",
                    remediation="Pin to specific version (e.g., package==1.0.0)",
                    confidence=0.9,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
            
            # Check for git/URL references
            if 'git' in line or 'http' in line:
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.DEPENDENCY_HIJACK,
                    severity=SeverityLevel.MEDIUM,
                    package=name,
                    registry=PackageRegistry.PYPI,
                    description=f"Dependency '{name}' uses external URL",
                    remediation="Use packages from PyPI",
                    confidence=0.8,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def analyze_ci_config(self, content: str, filename: str) -> List[SupplyChainVulnerability]:
        """Analyze CI/CD configuration for vulnerabilities (offline)"""
        vulnerabilities = []
        
        # Secret patterns in CI configs
        secret_patterns = [
            (r'password\s*[=:]\s*["\']?([^"\'\s]+)', 'password'),
            (r'api[_-]?key\s*[=:]\s*["\']?([^"\'\s]+)', 'api_key'),
            (r'secret\s*[=:]\s*["\']?([^"\'\s]+)', 'secret'),
            (r'token\s*[=:]\s*["\']?([^"\'\s]+)', 'token'),
            (r'AWS_SECRET_ACCESS_KEY\s*[=:]\s*["\']?([^"\'\s]+)', 'aws_secret'),
        ]
        
        for pattern, secret_type in secret_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if len(match) > 5 and not match.startswith('$'):  # Not a variable reference
                    vuln = SupplyChainVulnerability(
                        vuln_type=SupplyChainVulnType.CI_CD_LEAK,
                        severity=SeverityLevel.CRITICAL,
                        package=filename,
                        registry=PackageRegistry.NPM,  # Placeholder
                        description=f"Hardcoded {secret_type} found in CI config",
                        evidence=f"Secret type: {secret_type}",
                        remediation="Use CI/CD secret management",
                        confidence=0.85,
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
        
        # Check for unsafe commands
        unsafe_patterns = [
            (r'curl\s+.*\|\s*(bash|sh)', 'curl piped to shell'),
            (r'wget\s+.*\|\s*(bash|sh)', 'wget piped to shell'),
            (r'eval\s+', 'eval command'),
            (r'\$\{.*\}.*run', 'variable interpolation in run'),
        ]
        
        for pattern, issue in unsafe_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                vuln = SupplyChainVulnerability(
                    vuln_type=SupplyChainVulnType.CI_CD_INJECTION,
                    severity=SeverityLevel.HIGH,
                    package=filename,
                    registry=PackageRegistry.NPM,
                    description=f"Unsafe pattern in CI config: {issue}",
                    remediation="Avoid executing untrusted scripts",
                    confidence=0.8,
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def get_report(self, format: str = "json") -> str:
        """Generate report"""
        if format == "json":
            return json.dumps({
                'scan_time': datetime.now().isoformat(),
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }, indent=2)
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - SUPPLY CHAIN SECURITY REPORT",
                "=" * 70,
                f"Total Vulnerabilities: {len(self.vulnerabilities)}",
                "",
            ]
            
            for vuln in self.vulnerabilities:
                lines.append(f"[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  Package: {vuln.package}")
                lines.append(f"  {vuln.description}")
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear results from RAM"""
        self.vulnerabilities = []
        self.stats = defaultdict(int)


# Convenience functions
def create_supply_chain_scanner() -> SupplyChainScanner:
    """Factory function"""
    return SupplyChainScanner()


__all__ = [
    'SupplyChainScanner',
    'SupplyChainVulnerability',
    'SupplyChainVulnType',
    'SeverityLevel',
    'PackageRegistry',
    'Package',
    'create_supply_chain_scanner',
]

__version__ = '1.0.0'
