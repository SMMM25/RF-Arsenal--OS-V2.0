#!/usr/bin/env python3
"""
RF Arsenal OS - GraphQL Security Testing Module
================================================

Professional GraphQL security testing with stealth-first design.
Comprehensive testing for GraphQL-specific vulnerabilities.

CAPABILITIES:
- Introspection query exploitation
- Query batching attacks
- Nested query depth attacks
- Field suggestion enumeration
- Injection attacks via GraphQL
- Authorization bypass testing
- Alias-based DoS detection

README COMPLIANCE:
- Stealth-First: Rate-limited queries
- RAM-Only: All findings stored in memory only
- No Telemetry: Zero external data transmission
- Offline-First: Schema analysis works offline

Author: RF Arsenal Security Team
License: Authorized Security Testing Only
"""

import asyncio
import json
import logging
import random
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

logger = logging.getLogger(__name__)


class GraphQLVulnType(Enum):
    """GraphQL vulnerability types"""
    INTROSPECTION_ENABLED = "introspection_enabled"
    BATCHING_ATTACK = "batching_attack_possible"
    DEPTH_ATTACK = "depth_attack_possible"
    ALIAS_OVERLOAD = "alias_overload_attack"
    FIELD_SUGGESTION = "field_suggestion_leak"
    SQL_INJECTION = "sql_injection_via_graphql"
    NOSQL_INJECTION = "nosql_injection_via_graphql"
    IDOR = "idor_via_graphql"
    AUTH_BYPASS = "authorization_bypass"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    DIRECTIVE_ABUSE = "directive_abuse"
    MUTATION_ABUSE = "mutation_abuse"
    SUBSCRIPTION_ABUSE = "subscription_abuse"
    RATE_LIMIT_MISSING = "rate_limiting_missing"
    DDOS_AMPLIFICATION = "ddos_amplification"


class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"


@dataclass
class GraphQLVulnerability:
    """Detected GraphQL vulnerability"""
    vuln_type: GraphQLVulnType
    severity: SeverityLevel
    endpoint: str
    description: str = ""
    evidence: Optional[str] = None
    query: Optional[str] = None
    remediation: str = ""
    confidence: float = 0.0
    cwe_id: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'type': self.vuln_type.value,
            'severity': self.severity.value,
            'endpoint': self.endpoint,
            'description': self.description,
            'evidence': self.evidence[:500] if self.evidence else None,
            'query': self.query[:200] if self.query else None,
            'remediation': self.remediation,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class GraphQLSchema:
    """Parsed GraphQL schema"""
    types: List[Dict] = field(default_factory=list)
    queries: List[str] = field(default_factory=list)
    mutations: List[str] = field(default_factory=list)
    subscriptions: List[str] = field(default_factory=list)


class GraphQLSecurityScanner:
    """
    GraphQL Security Scanner
    
    Tests:
    - Introspection
    - Query complexity attacks
    - Injection vulnerabilities
    - Authorization bypass
    
    README COMPLIANCE:
    - Stealth-First: Rate-limited queries
    - RAM-Only: No persistent storage
    - No Telemetry: Zero reporting
    """
    
    # Introspection query
    INTROSPECTION_QUERY = """
        query IntrospectionQuery {
            __schema {
                types {
                    name
                    kind
                    fields {
                        name
                        type { name kind }
                        args { name type { name } }
                    }
                }
                queryType { name }
                mutationType { name }
                subscriptionType { name }
            }
        }
    """
    
    # Injection payloads
    INJECTION_PAYLOADS = [
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "'; DROP TABLE users;--",
        "admin'--",
        '{"$ne": null}',
        '{"$gt": ""}',
        '{"$regex": ".*"}',
    ]
    
    def __init__(self):
        """Initialize scanner"""
        self.vulnerabilities: List[GraphQLVulnerability] = []
        self.schema: Optional[GraphQLSchema] = None
        self.stats = defaultdict(int)
        self._authorized = False
        
        logger.info("GraphQLSecurityScanner initialized")
    
    def authorize(self, confirmation: str = "I_AUTHORIZE_GRAPHQL_TESTING") -> bool:
        """Authorize testing"""
        if confirmation == "I_AUTHORIZE_GRAPHQL_TESTING":
            self._authorized = True
            return True
        return False
    
    async def _make_request(
        self,
        url: str,
        query: str,
        variables: Optional[Dict] = None,
        headers: Optional[Dict] = None,
    ) -> Tuple[Optional[int], Optional[Dict], float]:
        """Make GraphQL request"""
        if not AIOHTTP_AVAILABLE:
            return None, None, 0
        
        start_time = time.time()
        
        try:
            timeout = aiohttp.ClientTimeout(total=30)
            request_headers = {'Content-Type': 'application/json'}
            if headers:
                request_headers.update(headers)
            
            payload = {'query': query}
            if variables:
                payload['variables'] = variables
            
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.post(
                    url,
                    json=payload,
                    headers=request_headers,
                    ssl=False,
                ) as response:
                    data = await response.json()
                    elapsed = time.time() - start_time
                    self.stats['queries'] += 1
                    return response.status, data, elapsed
        
        except Exception as e:
            logger.debug(f"Request error: {e}")
            return None, None, time.time() - start_time
    
    async def test_introspection(self, endpoint: str) -> List[GraphQLVulnerability]:
        """Test if introspection is enabled"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        status, data, _ = await self._make_request(endpoint, self.INTROSPECTION_QUERY)
        
        if status == 200 and data:
            schema_data = data.get('data', {}).get('__schema')
            
            if schema_data:
                # Parse schema
                self.schema = GraphQLSchema(
                    types=schema_data.get('types', []),
                    queries=[f.get('name') for f in schema_data.get('queryType', {}).get('fields', []) or []],
                    mutations=[f.get('name') for f in schema_data.get('mutationType', {}).get('fields', []) or []] if schema_data.get('mutationType') else [],
                )
                
                type_count = len(self.schema.types)
                
                vuln = GraphQLVulnerability(
                    vuln_type=GraphQLVulnType.INTROSPECTION_ENABLED,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    description=f"GraphQL introspection enabled - {type_count} types exposed",
                    evidence=f"Schema retrieved with {type_count} types",
                    remediation="Disable introspection in production",
                    confidence=1.0,
                    cwe_id="CWE-200",
                    metadata={'type_count': type_count},
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def test_batching(
        self,
        endpoint: str,
        batch_size: int = 100,
    ) -> List[GraphQLVulnerability]:
        """Test query batching"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        # Create batch of queries
        batch_query = [
            {'query': '{ __typename }'}
            for _ in range(batch_size)
        ]
        
        try:
            timeout = aiohttp.ClientTimeout(total=30)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.post(
                    endpoint,
                    json=batch_query,
                    headers={'Content-Type': 'application/json'},
                    ssl=False,
                ) as response:
                    data = await response.json()
                    
                    if isinstance(data, list) and len(data) >= batch_size * 0.9:
                        vuln = GraphQLVulnerability(
                            vuln_type=GraphQLVulnType.BATCHING_ATTACK,
                            severity=SeverityLevel.MEDIUM,
                            endpoint=endpoint,
                            description=f"Query batching allowed - {len(data)} queries executed",
                            evidence=f"Batch of {batch_size} queries processed",
                            remediation="Limit batch query size",
                            confidence=0.9,
                            cwe_id="CWE-770",
                        )
                        vulnerabilities.append(vuln)
                        self.vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.debug(f"Batching test error: {e}")
        
        return vulnerabilities
    
    async def test_depth_attack(
        self,
        endpoint: str,
        depth: int = 10,
    ) -> List[GraphQLVulnerability]:
        """Test nested query depth attack"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        # Build deeply nested query using introspection
        nested_query = '{ __schema { types { '
        for _ in range(depth):
            nested_query += 'fields { type { '
        nested_query += 'name'
        for _ in range(depth):
            nested_query += ' } }'
        nested_query += ' } } }'
        
        status, data, elapsed = await self._make_request(endpoint, nested_query)
        
        if status == 200 and elapsed > 2.0:
            vuln = GraphQLVulnerability(
                vuln_type=GraphQLVulnType.DEPTH_ATTACK,
                severity=SeverityLevel.MEDIUM,
                endpoint=endpoint,
                description=f"Deep nested query executed in {elapsed:.1f}s",
                query=nested_query[:100] + '...',
                evidence=f"Depth: {depth}, Time: {elapsed:.1f}s",
                remediation="Implement query depth limiting",
                confidence=0.85,
                cwe_id="CWE-770",
            )
            vulnerabilities.append(vuln)
            self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def test_alias_overload(
        self,
        endpoint: str,
        alias_count: int = 100,
    ) -> List[GraphQLVulnerability]:
        """Test alias-based overload attack"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        # Build query with many aliases
        aliases = [f'a{i}: __typename' for i in range(alias_count)]
        alias_query = '{ ' + ' '.join(aliases) + ' }'
        
        status, data, elapsed = await self._make_request(endpoint, alias_query)
        
        if status == 200 and data:
            result_data = data.get('data', {})
            if len(result_data) >= alias_count * 0.9:
                vuln = GraphQLVulnerability(
                    vuln_type=GraphQLVulnType.ALIAS_OVERLOAD,
                    severity=SeverityLevel.MEDIUM,
                    endpoint=endpoint,
                    description=f"Alias overload attack possible - {alias_count} aliases executed",
                    evidence=f"{len(result_data)} results returned",
                    remediation="Limit number of aliases per query",
                    confidence=0.9,
                    cwe_id="CWE-770",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def test_injection(
        self,
        endpoint: str,
        query_template: str,
        variable_name: str,
    ) -> List[GraphQLVulnerability]:
        """Test for injection vulnerabilities"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        for payload in self.INJECTION_PAYLOADS:
            variables = {variable_name: payload}
            status, data, _ = await self._make_request(endpoint, query_template, variables)
            
            if data:
                errors = data.get('errors', [])
                response_str = json.dumps(data).lower()
                
                # Check for SQL error signatures
                sql_signatures = ['sql', 'syntax', 'mysql', 'postgres', 'sqlite']
                if any(sig in response_str for sig in sql_signatures):
                    vuln = GraphQLVulnerability(
                        vuln_type=GraphQLVulnType.SQL_INJECTION,
                        severity=SeverityLevel.CRITICAL,
                        endpoint=endpoint,
                        description="SQL injection via GraphQL variable",
                        query=query_template[:100],
                        evidence=f"SQL error with payload: {payload}",
                        remediation="Use parameterized queries",
                        confidence=0.9,
                        cwe_id="CWE-89",
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
                    break
                
                # Check for NoSQL error signatures
                nosql_signatures = ['mongodb', 'objectid', 'bson']
                if any(sig in response_str for sig in nosql_signatures):
                    vuln = GraphQLVulnerability(
                        vuln_type=GraphQLVulnType.NOSQL_INJECTION,
                        severity=SeverityLevel.CRITICAL,
                        endpoint=endpoint,
                        description="NoSQL injection via GraphQL variable",
                        query=query_template[:100],
                        evidence=f"NoSQL error with payload: {payload}",
                        remediation="Sanitize and validate inputs",
                        confidence=0.85,
                        cwe_id="CWE-943",
                    )
                    vulnerabilities.append(vuln)
                    self.vulnerabilities.append(vuln)
                    break
        
        return vulnerabilities
    
    async def test_authorization(
        self,
        endpoint: str,
        queries: List[str],
        auth_header: Optional[str] = None,
    ) -> List[GraphQLVulnerability]:
        """Test authorization on queries"""
        vulnerabilities = []
        
        if not self._authorized:
            return vulnerabilities
        
        for query in queries:
            # Test without auth
            status, data, _ = await self._make_request(endpoint, query)
            
            if status == 200 and data and not data.get('errors'):
                vuln = GraphQLVulnerability(
                    vuln_type=GraphQLVulnType.AUTH_BYPASS,
                    severity=SeverityLevel.HIGH,
                    endpoint=endpoint,
                    description="GraphQL query accessible without authentication",
                    query=query[:100],
                    remediation="Implement proper authorization checks",
                    confidence=0.85,
                    cwe_id="CWE-285",
                )
                vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def enumerate_fields(self, endpoint: str) -> List[str]:
        """Enumerate fields via suggestion errors"""
        discovered_fields = []
        
        if not self._authorized:
            return discovered_fields
        
        # Common field names to test
        test_fields = [
            'user', 'users', 'admin', 'password', 'email', 'token',
            'secret', 'id', 'role', 'permission', 'data', 'info',
        ]
        
        for field in test_fields:
            query = f'{{ {field} }}'
            status, data, _ = await self._make_request(endpoint, query)
            
            if data and data.get('errors'):
                for error in data['errors']:
                    message = error.get('message', '')
                    
                    # Check for field suggestions
                    if 'Did you mean' in message or 'suggestion' in message.lower():
                        vuln = GraphQLVulnerability(
                            vuln_type=GraphQLVulnType.FIELD_SUGGESTION,
                            severity=SeverityLevel.LOW,
                            endpoint=endpoint,
                            description="GraphQL provides field suggestions",
                            evidence=f"Suggestion for '{field}': {message[:100]}",
                            remediation="Disable field suggestions in production",
                            confidence=0.9,
                        )
                        self.vulnerabilities.append(vuln)
                        
                        # Extract suggested fields
                        import re
                        suggestions = re.findall(r'"(\w+)"', message)
                        discovered_fields.extend(suggestions)
        
        return list(set(discovered_fields))
    
    async def scan(
        self,
        endpoint: str,
        auth_headers: Optional[Dict] = None,
    ) -> List[GraphQLVulnerability]:
        """Run comprehensive GraphQL security scan"""
        if not self._authorized:
            logger.error("Scan not authorized")
            return []
        
        all_vulnerabilities = []
        
        logger.info(f"Starting GraphQL security scan: {endpoint}")
        
        # Introspection test
        vulns = await self.test_introspection(endpoint)
        all_vulnerabilities.extend(vulns)
        
        # Batching test
        vulns = await self.test_batching(endpoint)
        all_vulnerabilities.extend(vulns)
        
        # Depth test
        vulns = await self.test_depth_attack(endpoint)
        all_vulnerabilities.extend(vulns)
        
        # Alias overload test
        vulns = await self.test_alias_overload(endpoint)
        all_vulnerabilities.extend(vulns)
        
        # Field enumeration
        await self.enumerate_fields(endpoint)
        
        logger.info(f"Scan complete. Found {len(all_vulnerabilities)} vulnerabilities")
        return all_vulnerabilities
    
    def get_report(self, format: str = "json") -> str:
        """Generate report"""
        if format == "json":
            return json.dumps({
                'scan_time': datetime.now().isoformat(),
                'queries_sent': self.stats['queries'],
                'schema': {
                    'types': len(self.schema.types) if self.schema else 0,
                    'queries': len(self.schema.queries) if self.schema else 0,
                    'mutations': len(self.schema.mutations) if self.schema else 0,
                },
                'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            }, indent=2)
        else:
            lines = [
                "=" * 70,
                "RF ARSENAL OS - GRAPHQL SECURITY REPORT",
                "=" * 70,
                f"Queries Sent: {self.stats['queries']}",
                f"Vulnerabilities: {len(self.vulnerabilities)}",
                "",
            ]
            
            if self.schema:
                lines.append(f"Schema: {len(self.schema.types)} types, {len(self.schema.queries)} queries")
            
            for vuln in self.vulnerabilities:
                lines.append(f"\n[{vuln.severity.value.upper()}] {vuln.vuln_type.value}")
                lines.append(f"  {vuln.description}")
            
            return "\n".join(lines)
    
    def clear_results(self):
        """Clear results from RAM"""
        self.vulnerabilities = []
        self.schema = None
        self.stats = defaultdict(int)


def create_graphql_scanner() -> GraphQLSecurityScanner:
    """Factory function"""
    return GraphQLSecurityScanner()


__all__ = [
    'GraphQLSecurityScanner',
    'GraphQLVulnerability',
    'GraphQLVulnType',
    'GraphQLSchema',
    'SeverityLevel',
    'create_graphql_scanner',
]

__version__ = '1.0.0'
